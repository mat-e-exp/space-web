<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defense - Protect Earth</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #0f0;
        }
        #gameCanvas {
            border: 2px solid #0f0;
            box-shadow: 0 0 20px #0f0;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
        }
        #scoreBox {
            background: rgba(0, 255, 0, 0.1);
            border: 3px solid #0f0;
            padding: 15px 25px;
            font-size: 36px;
            font-weight: bold;
            color: #0f0;
            text-shadow: 0 0 15px #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            min-width: 150px;
            text-align: center;
        }
        #scoreBox.pulse {
            animation: scorePulse 0.3s ease-out;
        }
        @keyframes scorePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); box-shadow: 0 0 30px rgba(0, 255, 0, 0.6); }
            100% { transform: scale(1); }
        }
        #soundToggle {
            position: absolute;
            top: 150px;
            left: 20px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #0f0;
            cursor: pointer;
            opacity: 0.9;
        }
        #soundToggle:hover {
            opacity: 1;
        }
        #superweaponsContainer {
            position: absolute;
            top: 500px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-top: 20px;
            border-top: 2px solid #333;
        }
        .superweapon-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
        }
        .superweapon-label {
            font-size: 10px;
            font-weight: bold;
            color: #555;
            text-transform: uppercase;
            text-align: left;
            letter-spacing: 1px;
            width: 50px;
        }
        .superweapon-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 3px solid #333;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5), inset 0 2px 4px rgba(255,255,255,0.1);
            cursor: default;
            transition: all 0.2s ease;
            position: relative;
        }
        .superweapon-btn .key-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: 900;
            color: #444;
        }
        .superweapon-item.available .superweapon-label {
            color: #fff;
        }
        .superweapon-item.available .superweapon-btn {
            cursor: pointer;
            animation: btnPulse 1.5s ease-in-out infinite;
        }
        .superweapon-item.available .superweapon-btn .key-hint {
            color: #fff;
        }
        .superweapon-count {
            font-size: 14px;
            font-weight: bold;
            color: #ffff00;
            margin-left: 5px;
            min-width: 25px;
        }
        .superweapon-item[data-weapon="shield"].available .superweapon-btn {
            background: radial-gradient(circle at 30% 30%, #00ffff, #006666);
            border-color: #00ffff;
            box-shadow: 0 0 15px #00ffff, 0 4px 8px rgba(0,0,0,0.5);
        }
        .superweapon-item[data-weapon="shield"].available .superweapon-label {
            color: #00ffff;
            text-shadow: 0 0 8px #00ffff;
        }
        .superweapon-item[data-weapon="hyperkill"].available .superweapon-btn {
            background: radial-gradient(circle at 30% 30%, #ff4444, #660000);
            border-color: #ff0000;
            box-shadow: 0 0 15px #ff0000, 0 4px 8px rgba(0,0,0,0.5);
        }
        .superweapon-item[data-weapon="hyperkill"].available .superweapon-label {
            color: #ff0000;
            text-shadow: 0 0 8px #ff0000;
        }
        .superweapon-item[data-weapon="satellites"].available .superweapon-btn {
            background: radial-gradient(circle at 30% 30%, #ffff44, #666600);
            border-color: #ffff00;
            box-shadow: 0 0 15px #ffff00, 0 4px 8px rgba(0,0,0,0.5);
        }
        .superweapon-item[data-weapon="satellites"].available .superweapon-label {
            color: #ffff00;
            text-shadow: 0 0 8px #ffff00;
        }
        .superweapon-item[data-weapon="quad"].available .superweapon-btn {
            background: radial-gradient(circle at 30% 30%, #ff44ff, #660066);
            border-color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff, 0 4px 8px rgba(0,0,0,0.5);
        }
        .superweapon-item[data-weapon="quad"].available .superweapon-label {
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
        }
        .superweapon-item[data-weapon="rockets"].available .superweapon-btn {
            background: radial-gradient(circle at 30% 30%, #ffaa44, #664400);
            border-color: #ff8800;
            box-shadow: 0 0 15px #ff8800, 0 4px 8px rgba(0,0,0,0.5);
        }
        .superweapon-item[data-weapon="rockets"].available .superweapon-label {
            color: #ff8800;
            text-shadow: 0 0 8px #ff8800;
        }
        .superweapon-item.active .superweapon-btn {
            transform: scale(0.95);
            box-shadow: 0 0 20px currentColor, 0 2px 4px rgba(0,0,0,0.5);
        }
        .superweapon-item.locked .superweapon-label {
            color: #333;
        }
        .superweapon-item.locked .superweapon-btn {
            opacity: 0.3;
            animation: none;
        }
        /* Auto-fire indicator */
        #autoFireIndicator {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 10px;
            padding-bottom: 10px;
            margin-bottom: 5px;
            border-bottom: 1px solid #333;
        }
        #autoFireIndicator .af-label {
            font-size: 10px;
            font-weight: bold;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 50px;
        }
        #autoFireIndicator .af-bar-container {
            width: 50px;
            height: 8px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }
        #autoFireIndicator .af-bar-fill {
            height: 100%;
            width: 100%;
            background: #555;
            transition: width 0.1s linear;
        }
        #autoFireIndicator.available .af-label {
            color: #00ff00;
            text-shadow: 0 0 8px #00ff00;
            animation: afFlash 0.5s ease-in-out infinite;
        }
        #autoFireIndicator.available .af-bar-fill {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }
        #autoFireIndicator.active .af-label {
            color: #ff8800;
            text-shadow: 0 0 8px #ff8800;
            animation: none;
        }
        #autoFireIndicator.active .af-bar-fill {
            background: #ff8800;
            box-shadow: 0 0 8px #ff8800;
        }
        #autoFireIndicator.recharging .af-label {
            color: #555;
            animation: none;
        }
        #autoFireIndicator.recharging .af-bar-fill {
            background: #444;
        }
        #autoFireIndicator.disabled .af-label {
            color: #333;
            animation: none;
        }
        #autoFireIndicator.disabled .af-bar-fill {
            background: #222;
        }
        @keyframes afFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes btnPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.08);
            }
        }
        #superweaponTimer {
            position: absolute;
            top: 130px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #0f0;
            text-shadow: 0 0 15px #0f0;
            display: none;
        }
        #superweaponTimer.active {
            display: block;
            animation: timerPulse 1s ease-in-out infinite;
        }
        @keyframes timerPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        #statusBars {
            position: absolute;
            top: 200px;
            left: 20px;
            width: 320px;
        }
        .status-bar {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .status-label {
            width: 90px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 8px;
        }
        .status-bar-container {
            width: 160px;
            height: 20px;
            background: #222;
            border: 2px solid;
            position: relative;
            overflow: hidden;
        }
        .status-bar-fill {
            height: 100%;
            box-shadow: 0 0 10px;
            transition: width 0.3s ease;
            width: 0%;
        }
        .status-percent {
            font-size: 16px;
            font-weight: bold;
            min-width: 50px;
            text-align: right;
            text-shadow: 0 0 8px;
        }
        /* Individual bar colors */
        /* Wave bar - Yellow */
        #waveBar {
            background: #ffff00;
            box-shadow: 0 0 8px #ffff00;
        }
        .status-bar:nth-child(1) .status-label {
            color: #ffff00;
            text-shadow: 0 0 6px #ffff00;
        }
        .status-bar:nth-child(1) .status-bar-container {
            border-color: #ffff00;
        }
        /* Lives bar - Red */
        #livesBar {
            background: #ff0000;
            box-shadow: 0 0 8px #ff0000;
        }
        .status-bar:nth-child(2) .status-label {
            color: #ff0000;
            text-shadow: 0 0 6px #ff0000;
        }
        .status-bar:nth-child(2) .status-bar-container {
            border-color: #ff0000;
        }
        /* Health bar - Blue */
        #healthBar {
            background: #0088ff;
            box-shadow: 0 0 8px #0088ff;
        }
        .status-bar:nth-child(3) .status-label {
            color: #0088ff;
            text-shadow: 0 0 6px #0088ff;
        }
        .status-bar:nth-child(3) .status-bar-container {
            border-color: #0088ff;
        }
        /* Speed bar - Green */
        #speedBar {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }
        .status-bar:nth-child(4) .status-label {
            color: #00ff00;
            text-shadow: 0 0 6px #00ff00;
        }
        .status-bar:nth-child(4) .status-bar-container {
            border-color: #00ff00;
        }
        /* Firepower bar - Orange */
        #firepowerBar {
            background: #ff8800;
            box-shadow: 0 0 8px #ff8800;
        }
        .status-bar:nth-child(5) .status-label {
            color: #ff8800;
            text-shadow: 0 0 6px #ff8800;
        }
        .status-bar:nth-child(5) .status-bar-container {
            border-color: #ff8800;
        }
        /* Shotspeed bar - Cyan */
        #shotspeedBar {
            background: #00ffff;
            box-shadow: 0 0 8px #00ffff;
        }
        .status-bar:nth-child(6) .status-label {
            color: #00ffff;
            text-shadow: 0 0 6px #00ffff;
        }
        .status-bar:nth-child(6) .status-bar-container {
            border-color: #00ffff;
        }
        /* Superpowers bar - Magenta */
        #superpowersBar {
            background: #ff00ff;
            box-shadow: 0 0 8px #ff00ff;
        }
        .status-bar:nth-child(7) .status-label {
            color: #ff00ff;
            text-shadow: 0 0 6px #ff00ff;
        }
        .status-bar:nth-child(7) .status-bar-container {
            border-color: #ff00ff;
        }
        /* Bullet Speed bar - Bright Cyan */
        #bulletSpeedBar {
            background: #00ddff;
            box-shadow: 0 0 8px #00ddff;
        }
        .status-bar:nth-child(8) .status-label {
            color: #00ddff;
            text-shadow: 0 0 6px #00ddff;
        }
        .status-bar:nth-child(8) .status-bar-container {
            border-color: #00ddff;
        }
        /* Status bar flash animation */
        .status-bar.flash {
            animation: statusFlash 0.5s ease-out;
        }
        @keyframes statusFlash {
            0% {
                background: rgba(255, 255, 255, 0.8);
                transform: scale(1.05);
            }
            50% {
                background: rgba(255, 255, 255, 0.4);
            }
            100% {
                background: transparent;
                transform: scale(1);
            }
        }
        #controls {
            position: absolute;
            top: 250px;
            right: 20px;
            text-align: left;
            font-size: 16px;
            font-weight: bold;
            opacity: 0.8;
            max-width: 280px;
            line-height: 1.8;
            color: #0f0;
            text-shadow: 0 0 8px #0f0;
        }
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 10px #0f0;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border: 3px solid #0f0;
            min-width: 280px;
        }
        #leaderboard h3 {
            margin: 0 0 15px 0;
            text-align: center;
            color: #0f0;
            font-size: 24px;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px 5px;
        }
        .leaderboard-entry.current {
            background: rgba(0, 255, 0, 0.2);
            border-left: 3px solid #0f0;
            padding-left: 7px;
        }
        .rank {
            color: #ffaa00;
            font-weight: bold;
            margin-right: 10px;
        }
        .high-score-message {
            color: #ffff00;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 15px #ffff00;
        }
        .game-over, .level-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 32px;
            display: none;
        }
        .game-over.show, .level-message.show {
            display: block;
        }
        .game-over {
            text-shadow: 0 0 20px #f00;
        }
        .level-message {
            top: 80px;
            transform: translateX(-50%);
            text-shadow: 0 0 20px #0f0;
            color: #0f0;
            font-size: 48px;
            animation: pulse 0.5s ease-in-out;
        }
        .pause-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 48px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px 80px;
            border: 3px solid #ffff00;
        }
        .pause-message.show {
            display: block;
        }
        .pause-message div {
            font-size: 20px;
            margin-top: 20px;
            opacity: 0.8;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        .game-over button {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background: #0f0;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
        }
        .game-over button:hover {
            background: #0f0;
            box-shadow: 0 0 20px #0f0;
        }
        .high-score-entry-box {
            display: none;
            margin: 30px auto;
            padding: 20px 40px;
            font-size: 28px;
            font-weight: bold;
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            border: 4px solid #ffd700;
            cursor: pointer;
            text-transform: uppercase;
            animation: flashHighScore 1s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        .high-score-entry-box.show {
            display: block;
        }
        .high-score-entry-box:hover {
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }
        @keyframes flashHighScore {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.05);
                box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            }
        }
        #levelChooser {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        #levelChooser.show {
            display: flex;
        }
        #levelChooser h2 {
            color: #0f0;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #0f0;
        }
        .wave-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 10px;
            margin-bottom: 40px;
            max-width: 800px;
        }
        .wave-btn {
            padding: 15px;
            font-size: 20px;
            font-weight: bold;
            background: rgba(0, 255, 0, 0.2);
            color: #0f0;
            border: 2px solid #0f0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
        }
        .wave-btn:hover {
            background: rgba(0, 255, 0, 0.4);
            box-shadow: 0 0 20px #0f0;
            transform: scale(1.1);
        }
        .loadout-section {
            margin-top: 20px;
        }
        .loadout-section h3 {
            color: #ff0;
            font-size: 24px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #ff0;
        }
        .loadout-btns {
            display: flex;
            gap: 20px;
            justify-content: center;
        }
        .loadout-btn {
            padding: 20px 40px;
            font-size: 18px;
            font-weight: bold;
            background: rgba(255, 255, 0, 0.2);
            color: #ff0;
            border: 3px solid #ff0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            text-align: center;
            min-width: 180px;
        }
        .loadout-btn:hover {
            background: rgba(255, 255, 0, 0.4);
            box-shadow: 0 0 20px #ff0;
            transform: scale(1.05);
        }
        .loadout-btn.selected {
            background: rgba(255, 255, 0, 0.5);
            box-shadow: 0 0 30px #ff0;
            border-width: 4px;
        }
        .loadout-btn small {
            display: block;
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.8;
        }
        .chooser-hint {
            color: #888;
            font-size: 16px;
            margin-top: 30px;
        }
        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .start-screen.hidden {
            display: none;
        }
        .start-title {
            font-size: 64px;
            color: #0f0;
            text-shadow: 0 0 20px #0f0;
            margin-bottom: 50px;
            font-weight: bold;
        }
        .start-message {
            font-size: 32px;
            color: #0f0;
            text-shadow: 0 0 15px #0f0;
            animation: blink 1.5s ease-in-out infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        /* Config Modal */
        #configModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 2500;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }
        #configModal.show {
            display: flex;
        }
        #configModal h2 {
            color: #0f0;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #0f0;
        }
        .config-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .config-tab {
            padding: 10px 20px;
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #0f0;
            color: #0f0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .config-tab:hover {
            background: rgba(0, 255, 0, 0.3);
        }
        .config-tab.active {
            background: rgba(0, 255, 0, 0.4);
            box-shadow: 0 0 15px #0f0;
        }
        .config-section {
            display: none;
            width: 100%;
            max-width: 600px;
            background: rgba(0, 50, 0, 0.5);
            border: 2px solid #0a0;
            padding: 20px;
            margin-bottom: 20px;
        }
        .config-section.active {
            display: block;
        }
        .config-section h3 {
            color: #0f0;
            margin-bottom: 15px;
            border-bottom: 1px solid #0a0;
            padding-bottom: 10px;
        }
        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 5px 0;
        }
        .config-row label {
            color: #8f8;
            font-size: 14px;
            flex: 1;
        }
        .config-row input[type="number"] {
            width: 80px;
            padding: 5px 10px;
            background: #001100;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-align: right;
        }
        .config-row input[type="range"] {
            width: 150px;
            accent-color: #0f0;
        }
        .config-row .value-display {
            width: 50px;
            text-align: right;
            color: #0f0;
            font-size: 14px;
        }
        .config-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .config-buttons button {
            padding: 12px 30px;
            font-size: 16px;
            background: rgba(0, 255, 0, 0.2);
            color: #0f0;
            border: 2px solid #0f0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        .config-buttons button:hover {
            background: rgba(0, 255, 0, 0.4);
            box-shadow: 0 0 20px #0f0;
        }
        .config-buttons button.reset {
            border-color: #f80;
            color: #f80;
            background: rgba(255, 136, 0, 0.2);
        }
        .config-buttons button.reset:hover {
            background: rgba(255, 136, 0, 0.4);
            box-shadow: 0 0 20px #f80;
        }
        .config-preset-row {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        .config-preset {
            padding: 8px 16px;
            font-size: 12px;
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            color: #ff0;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        .config-preset:hover {
            background: rgba(255, 255, 0, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1000" height="1000"></canvas>
    <div id="ui">
        <div id="scoreBox"><span id="score">0</span></div>
    </div>
    <div id="soundToggle" onclick="toggleSound()">
        <span id="soundStatus">ðŸ”Š Sound: ON</span>
    </div>
    <div id="superweaponTimer"></div>
    <div id="superweaponsContainer">
        <div id="autoFireIndicator" class="available">
            <div class="af-label">AUTO</div>
            <div class="af-bar-container">
                <div class="af-bar-fill" id="autoFireBar"></div>
            </div>
        </div>
        <div class="superweapon-item" data-weapon="shield">
            <div class="superweapon-label">SHIELD</div>
            <div class="superweapon-btn"><span class="key-hint">1</span></div>
        </div>
        <div class="superweapon-item" data-weapon="hyperkill">
            <div class="superweapon-label">HYPER</div>
            <div class="superweapon-btn"><span class="key-hint">2</span></div>
        </div>
        <div class="superweapon-item" data-weapon="satellites">
            <div class="superweapon-label">SATS</div>
            <div class="superweapon-btn"><span class="key-hint">3</span></div>
        </div>
        <div class="superweapon-item" data-weapon="quad">
            <div class="superweapon-label">QUAD</div>
            <div class="superweapon-btn"><span class="key-hint">4</span></div>
        </div>
        <div class="superweapon-item" data-weapon="rockets">
            <div class="superweapon-label">ROCKET</div>
            <div class="superweapon-btn"><span class="key-hint">5</span></div>
        </div>
    </div>
    <div id="statusBars">
        <div class="status-bar">
            <div class="status-label">WAVE:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="waveBar"></div>
            </div>
            <div class="status-percent" id="wavePercent">0%</div>
        </div>
        <div class="status-bar">
            <div class="status-label">LIVES:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="livesBar"></div>
            </div>
            <div class="status-percent" id="livesPercent">0%</div>
        </div>
        <div class="status-bar">
            <div class="status-label">EARTH HP:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="healthBar"></div>
            </div>
            <div class="status-percent" id="healthPercent">0%</div>
        </div>
        <div class="status-bar">
            <div class="status-label">SPEED:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="speedBar"></div>
            </div>
            <div class="status-percent" id="speedPercent">0%</div>
        </div>
        <div class="status-bar">
            <div class="status-label">FIREPOWER:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="firepowerBar"></div>
            </div>
            <div class="status-percent" id="firepowerPercent">0%</div>
        </div>
        <div class="status-bar">
            <div class="status-label">SHOTSPEED:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="shotspeedBar"></div>
            </div>
            <div class="status-percent" id="shotspeedPercent">0%</div>
        </div>
        <div class="status-bar">
            <div class="status-label">SUPERPOWERS:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="superpowersBar"></div>
            </div>
            <div class="status-percent" id="superpowersPercent">0%</div>
        </div>
        <div class="status-bar">
            <div class="status-label">BULLET SPD:</div>
            <div class="status-bar-container">
                <div class="status-bar-fill" id="bulletSpeedBar"></div>
            </div>
            <div class="status-percent" id="bulletSpeedPercent">0%</div>
        </div>
    </div>
    <div id="leaderboard">
        <h3>HIGH SCORES</h3>
        <div id="leaderboardList"></div>
    </div>
    <div id="controls">
        <div>Q/A: Rotate</div>
        <div>P: Fire (Hold for Auto)</div>
        <div>ENTER: Pause</div>
        <div>DEL: Sound</div>
    </div>
    <div class="level-message" id="levelMessage"></div>
    <div class="pause-message" id="pauseMessage">
        PAUSED
        <div>Press ENTER to resume</div>
    </div>
    <div class="game-over" id="gameOver">
        <div style="color: #f00; font-size: 64px; font-weight: bold; margin-bottom: 20px;">GAME OVER!</div>
        <div id="gameOverReason" style="color: #ff0; font-size: 32px; margin-bottom: 30px; text-shadow: 0 0 15px #ff0;"></div>
        <div class="high-score-entry-box" id="highScoreEntryBox" onclick="enterHighScoreName()">
            HIGH SCORE! ENTER NAME!
        </div>
        <div id="highScoreMessage" class="high-score-message"></div>
        <div>Final Score: <span id="finalScore">0</span></div>
        <div>Waves Survived: <span id="finalWave">0</span></div>
        <button onclick="continueGame()">CONTINUE</button>
        <button onclick="restartGame()">PLAY AGAIN</button>
    </div>

    <div class="start-screen" id="startScreen">
        <div class="start-title">SPACE DEFENSE</div>
        <div class="start-message">PRESS P TO PLAY</div>
        <div style="font-size: 18px; color: #888; margin-top: 30px; opacity: 0.7;">Press = for Level Chooser</div>
        <div style="font-size: 18px; color: #888; margin-top: 10px; opacity: 0.7;">Press C for Config</div>
    </div>

    <!-- Config Modal -->
    <div id="configModal">
        <h2>GAME CONFIGURATION</h2>

        <div class="config-preset-row">
            <button class="config-preset" onclick="applyPreset('easy')">EASY</button>
            <button class="config-preset" onclick="applyPreset('normal')">NORMAL</button>
            <button class="config-preset" onclick="applyPreset('hard')">HARD</button>
            <button class="config-preset" onclick="applyPreset('insane')">INSANE</button>
        </div>

        <div class="config-tabs">
            <div class="config-tab active" onclick="showConfigTab('player')">PLAYER</div>
            <div class="config-tab" onclick="showConfigTab('combat')">COMBAT</div>
            <div class="config-tab" onclick="showConfigTab('enemies')">ENEMIES</div>
            <div class="config-tab" onclick="showConfigTab('powerups')">POWER-UPS</div>
            <div class="config-tab" onclick="showConfigTab('superweapons')">SUPERWEAPONS</div>
        </div>

        <!-- Player Section -->
        <div class="config-section active" id="config-player">
            <h3>PLAYER SETTINGS</h3>
            <div class="config-row">
                <label>Starting Lives</label>
                <input type="number" id="cfg-startingLives" min="1" max="10" value="3">
            </div>
            <div class="config-row">
                <label>Max Lives</label>
                <input type="number" id="cfg-maxLives" min="1" max="20" value="5">
            </div>
            <div class="config-row">
                <label>Starting Earth Health</label>
                <input type="number" id="cfg-startingEarthHealth" min="1" max="50" value="20">
            </div>
            <div class="config-row">
                <label>Max Earth Health</label>
                <input type="number" id="cfg-maxEarthHealth" min="1" max="100" value="30">
            </div>
            <div class="config-row">
                <label>Ship Size</label>
                <input type="number" id="cfg-shipSize" min="8" max="20" value="12">
            </div>
            <div class="config-row">
                <label>Orbit Radius</label>
                <input type="number" id="cfg-orbitRadius" min="50" max="150" value="70">
            </div>
        </div>

        <!-- Combat Section -->
        <div class="config-section" id="config-combat">
            <h3>COMBAT SETTINGS</h3>
            <div class="config-row">
                <label>Starting Rotation Speed</label>
                <input type="number" id="cfg-startingRotationSpeed" min="0.01" max="0.1" step="0.005" value="0.035">
            </div>
            <div class="config-row">
                <label>Max Rotation Speed</label>
                <input type="number" id="cfg-maxRotationSpeed" min="0.05" max="0.2" step="0.01" value="0.12">
            </div>
            <div class="config-row">
                <label>Starting Fire Rate (lower = faster)</label>
                <input type="number" id="cfg-startingFireRate" min="5" max="30" value="15">
            </div>
            <div class="config-row">
                <label>Min Fire Rate (fastest)</label>
                <input type="number" id="cfg-minFireRate" min="2" max="15" value="5">
            </div>
            <div class="config-row">
                <label>Starting Bullet Speed</label>
                <input type="number" id="cfg-startingBulletSpeed" min="5" max="20" value="10">
            </div>
            <div class="config-row">
                <label>Max Bullet Speed</label>
                <input type="number" id="cfg-maxBulletSpeed" min="10" max="30" value="18">
            </div>
            <div class="config-row">
                <label>Max Bullet Mode (1-5)</label>
                <input type="number" id="cfg-maxBulletMode" min="1" max="5" value="5">
            </div>
        </div>

        <!-- Enemies Section -->
        <div class="config-section" id="config-enemies">
            <h3>ENEMY SETTINGS</h3>
            <div class="config-row">
                <label>Base Spawn Rate (frames)</label>
                <input type="number" id="cfg-baseSpawnRate" min="30" max="200" value="90">
            </div>
            <div class="config-row">
                <label>Enemy Speed Multiplier</label>
                <input type="number" id="cfg-enemySpeedMult" min="0.5" max="3" step="0.1" value="1">
            </div>
            <div class="config-row">
                <label>Enemy Health Multiplier</label>
                <input type="number" id="cfg-enemyHealthMult" min="0.5" max="3" step="0.1" value="1">
            </div>
            <div class="config-row">
                <label>Points Multiplier</label>
                <input type="number" id="cfg-pointsMult" min="0.5" max="5" step="0.5" value="1">
            </div>
        </div>

        <!-- Power-ups Section -->
        <div class="config-section" id="config-powerups">
            <h3>POWER-UP SETTINGS</h3>
            <div class="config-row">
                <label>Power-up Drop Chance (%)</label>
                <input type="number" id="cfg-powerupChance" min="5" max="100" value="35">
            </div>
            <div class="config-row">
                <label>Mirror Ship Duration (seconds)</label>
                <input type="number" id="cfg-mirrorDuration" min="10" max="120" value="30">
            </div>
            <div class="config-row">
                <label>Speed Boost Increment</label>
                <input type="number" id="cfg-speedIncrement" min="0.005" max="0.03" step="0.001" value="0.01">
            </div>
            <div class="config-row">
                <label>Extra Life Every X Points</label>
                <input type="number" id="cfg-extraLifePoints" min="5000" max="50000" step="1000" value="10000">
            </div>
        </div>

        <!-- Superweapons Section -->
        <div class="config-section" id="config-superweapons">
            <h3>SUPERWEAPON SETTINGS</h3>
            <div class="config-row">
                <label>Superweapon Duration (seconds)</label>
                <input type="number" id="cfg-superweaponDuration" min="5" max="30" value="10">
            </div>
            <div class="config-row">
                <label>Superweapons Unlock at Wave</label>
                <input type="number" id="cfg-superweaponUnlock" min="1" max="10" value="5">
            </div>
            <div class="config-row">
                <label>Shield Radius</label>
                <input type="number" id="cfg-shieldRadius" min="100" max="250" value="150">
            </div>
            <div class="config-row">
                <label>Satellite Orbit Radius</label>
                <input type="number" id="cfg-satelliteRadius" min="100" max="280" value="200">
            </div>
            <div class="config-row">
                <label>Missile Damage</label>
                <input type="number" id="cfg-missileDamage" min="1" max="10" value="2">
            </div>
        </div>

        <div class="config-buttons">
            <button onclick="saveConfig()">SAVE & CLOSE</button>
            <button class="reset" onclick="resetConfigToDefaults()">RESET DEFAULTS</button>
            <button onclick="closeConfig()">CANCEL</button>
        </div>
    </div>

    <div id="levelChooser">
        <h2>LEVEL CHOOSER</h2>
        <div class="wave-grid" id="waveGrid">
            <!-- Wave buttons 1-20 will be generated here -->
        </div>
        <div class="loadout-section">
            <h3>SELECT LOADOUT:</h3>
            <div class="loadout-btns">
                <button class="loadout-btn selected" onclick="selectLoadout('fresh')" id="loadout-fresh">
                    FRESH START
                    <small>Base stats</small>
                </button>
                <button class="loadout-btn" onclick="selectLoadout('mid')" id="loadout-mid">
                    MID-GAME
                    <small>Triple shot, upgrades</small>
                </button>
                <button class="loadout-btn" onclick="selectLoadout('late')" id="loadout-late">
                    LATE-GAME
                    <small>Quintuple, max upgrades</small>
                </button>
            </div>
        </div>
        <div class="chooser-hint">Press ESC to close</div>
    </div>

    <script>
        // Global game configuration (loaded from game-config.json)
        let gameConfig = null;
        let configLoaded = false;

        // Load configuration from external JSON file
        async function loadGameConfig() {
            try {
                const response = await fetch('game-config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                gameConfig = await response.json();
                configLoaded = true;
                console.log('Game config loaded:', gameConfig.version);
                return true;
            } catch (error) {
                console.error('Failed to load game config:', error);
                alert('Failed to load game configuration.\\n\\nPlease run the game via a web server:\\npython3 -m http.server 3110');
                return false;
            }
        }

        // Configuration is now loaded from game-config.json via loadGameConfig()


        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Audio context for 8-bit sounds
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // Sound toggle state
        let soundEnabled = true;

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const statusEl = document.getElementById('soundStatus');
            if (soundEnabled) {
                statusEl.textContent = 'ðŸ”Š Sound: ON';
                if (!gameState.paused && !gameState.gameOver) {
                    startBackgroundMusic();
                }
            } else {
                statusEl.textContent = 'ðŸ”‡ Sound: OFF';
                stopBackgroundMusic();
            }
        }

        // High score management
        function getHighScores() {
            const scores = localStorage.getItem('spaceDefenseHighScores');
            return scores ? JSON.parse(scores) : [];
        }

        function saveHighScore(score, wave, name) {
            const highScores = getHighScores();
            highScores.push({ score, wave, name, date: new Date().toISOString() });
            highScores.sort((a, b) => b.score - a.score);
            const top10 = highScores.slice(0, 10);
            localStorage.setItem('spaceDefenseHighScores', JSON.stringify(top10));
            return top10;
        }

        function isHighScore(score) {
            const highScores = getHighScores();
            if (highScores.length < 10) return true;
            return score > highScores[9].score;
        }

        function resetHighScores() {
            localStorage.removeItem('spaceDefenseHighScores');
            updateLeaderboard();
            console.log('High scores reset');
        }

        function updateLeaderboard(currentScore = null) {
            const highScores = getHighScores();
            const leaderboardList = document.getElementById('leaderboardList');

            if (highScores.length === 0) {
                leaderboardList.innerHTML = '<div style="text-align: center; opacity: 0.5;">No scores yet</div>';
                return;
            }

            leaderboardList.innerHTML = highScores.map((entry, index) => {
                const isCurrent = currentScore !== null && entry.score === currentScore;
                const displayName = entry.name || 'PLAYER';
                const waveDisplay = entry.wave ? `L${entry.wave} ` : '';
                return `<div class="leaderboard-entry ${isCurrent ? 'current' : ''}">
                    <span><span class="rank">#${index + 1}</span>${waveDisplay}${displayName}</span>
                    <span>${entry.score}</span>
                </div>`;
            }).join('');
        }

        // 8-bit sound generation (all wrapped with soundEnabled check)
        function playShootSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.08);

            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.08);
        }

        // Small alien explosion - quick pop
        function playSmallExplosionSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // Quick pop
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

            osc.start(now);
            osc.stop(now + 0.15);

            // Crackle
            const crackle = audioCtx.createOscillator();
            const crackleGain = audioCtx.createGain();
            crackle.connect(crackleGain);
            crackleGain.connect(audioCtx.destination);

            crackle.type = 'square';
            crackle.frequency.setValueAtTime(600, now);
            crackle.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            crackleGain.gain.setValueAtTime(0.15, now);
            crackleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

            crackle.start(now);
            crackle.stop(now + 0.1);
        }

        // Medium alien explosion - deeper boom
        function playMediumExplosionSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // Deeper boom
            [120, 90, 60].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, now + i * 0.02);
                osc.frequency.exponentialRampToValueAtTime(20, now + 0.25);
                gain.gain.setValueAtTime(0.25, now + i * 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

                osc.start(now + i * 0.02);
                osc.stop(now + 0.25);
            });

            // Crackle burst
            [700, 900].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                osc.start(now);
                osc.stop(now + 0.15);
            });
        }

        // Large alien explosion - big boom with rumble
        function playLargeExplosionSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // Deep rumble
            [80, 100, 60, 120].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, now + i * 0.03);
                osc.frequency.exponentialRampToValueAtTime(15, now + 0.4);
                gain.gain.setValueAtTime(0.3, now + i * 0.03);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                osc.start(now + i * 0.03);
                osc.stop(now + 0.4);
            });

            // High frequency destruction
            [1000, 800, 1200].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.02);
                osc.frequency.exponentialRampToValueAtTime(60, now + 0.2);
                gain.gain.setValueAtTime(0.2, now + i * 0.02);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

                osc.start(now + i * 0.02);
                osc.stop(now + 0.2);
            });

            // White noise burst
            const bufferSize = audioCtx.sampleRate * 0.25;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            noise.buffer = buffer;
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);

            noiseGain.gain.setValueAtTime(0.25, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

            noise.start(now);
        }

        // Bonus ship explosion - sparkly
        function playBonusExplosionSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // Sparkly ascending notes
            [659.25, 783.99, 987.77].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                gain.gain.setValueAtTime(0.2, now + i * 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.15);

                osc.start(now + i * 0.05);
                osc.stop(now + i * 0.05 + 0.15);
            });
        }

        function playExtraLifeSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // Triumphant fanfare
            const notes = [523.25, 659.25, 783.99, 1046.50, 1318.51];
            notes.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.1);
                gain.gain.setValueAtTime(0.25, now + i * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.25);

                osc.start(now + i * 0.1);
                osc.stop(now + i * 0.1 + 0.25);
            });
        }

        function playScreenClearSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // Massive explosion
            [40, 60, 80, 100].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.8);
                gain.gain.setValueAtTime(0.4, now + i * 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);

                osc.start(now + i * 0.05);
                osc.stop(now + 0.8);
            });

            // White noise burst
            const bufferSize = audioCtx.sampleRate * 0.6;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            noise.buffer = buffer;
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);

            noiseGain.gain.setValueAtTime(0.5, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

            noise.start(now);
        }

        // Shield electric zap sound (8-bit sparking)
        function playShieldZapSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            // Electric crackle - rapid frequency jumps
            const osc1 = audioCtx.createOscillator();
            const gain1 = audioCtx.createGain();
            osc1.connect(gain1);
            gain1.connect(audioCtx.destination);
            osc1.type = 'square';
            // Rapid frequency changes for electric effect
            osc1.frequency.setValueAtTime(2000, now);
            osc1.frequency.setValueAtTime(800, now + 0.02);
            osc1.frequency.setValueAtTime(3000, now + 0.04);
            osc1.frequency.setValueAtTime(1200, now + 0.06);
            osc1.frequency.setValueAtTime(2500, now + 0.08);
            osc1.frequency.setValueAtTime(600, now + 0.10);
            gain1.gain.setValueAtTime(0.15, now);
            gain1.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
            osc1.start(now);
            osc1.stop(now + 0.12);

            // Low buzz undertone
            const osc2 = audioCtx.createOscillator();
            const gain2 = audioCtx.createGain();
            osc2.connect(gain2);
            gain2.connect(audioCtx.destination);
            osc2.type = 'sawtooth';
            osc2.frequency.setValueAtTime(80, now);
            osc2.frequency.setValueAtTime(60, now + 0.1);
            gain2.gain.setValueAtTime(0.1, now);
            gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc2.start(now);
            osc2.stop(now + 0.1);
        }

        function playPowerUpSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            // Sparkly rapid ascending arpeggio with shimmer
            const now = audioCtx.currentTime;
            const notes = [659.25, 783.99, 987.77, 1174.66, 1318.51, 1567.98]; // E-G-B-D-E-G (higher octave)

            notes.forEach((freq, i) => {
                // Main sparkle tone (square wave for 8-bit sparkle)
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                gain.gain.setValueAtTime(0.15, now + i * 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.15);

                osc.start(now + i * 0.05);
                osc.stop(now + i * 0.05 + 0.15);

                // Harmonic shimmer (higher octave)
                const shimmerOsc = audioCtx.createOscillator();
                const shimmerGain = audioCtx.createGain();

                shimmerOsc.connect(shimmerGain);
                shimmerGain.connect(audioCtx.destination);

                shimmerOsc.type = 'sine';
                shimmerOsc.frequency.setValueAtTime(freq * 2, now + i * 0.05);
                shimmerGain.gain.setValueAtTime(0.08, now + i * 0.05);
                shimmerGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.12);

                shimmerOsc.start(now + i * 0.05);
                shimmerOsc.stop(now + i * 0.05 + 0.12);
            });

            // Final sparkle burst
            const burstOsc = audioCtx.createOscillator();
            const burstGain = audioCtx.createGain();

            burstOsc.connect(burstGain);
            burstGain.connect(audioCtx.destination);

            burstOsc.type = 'triangle';
            burstOsc.frequency.setValueAtTime(2093, now + 0.3); // High C
            burstOsc.frequency.exponentialRampToValueAtTime(3000, now + 0.4);
            burstGain.gain.setValueAtTime(0.12, now + 0.3);
            burstGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

            burstOsc.start(now + 0.3);
            burstOsc.stop(now + 0.4);
        }

        // Superweapon countdown tick sound (gets more urgent as time runs out)
        function playSuperweaponTickSound(secondsLeft) {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;
            // Higher pitch and more urgent as time runs out
            const baseFreq = 440 + (5 - secondsLeft) * 100; // 440Hz at 5s, 840Hz at 1s

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.type = 'square';
            osc.frequency.setValueAtTime(baseFreq, now);
            osc.frequency.setValueAtTime(baseFreq * 0.8, now + 0.05); // Slight drop

            gain.gain.setValueAtTime(0.12, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

            osc.start(now);
            osc.stop(now + 0.1);

            // Add warning beep for last 2 seconds
            if (secondsLeft <= 2) {
                const warnOsc = audioCtx.createOscillator();
                const warnGain = audioCtx.createGain();

                warnOsc.connect(warnGain);
                warnGain.connect(audioCtx.destination);

                warnOsc.type = 'square';
                warnOsc.frequency.setValueAtTime(1200, now + 0.12);

                warnGain.gain.setValueAtTime(0.08, now + 0.12);
                warnGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);

                warnOsc.start(now + 0.12);
                warnOsc.stop(now + 0.18);
            }
        }

        // Superweapon expired sound (dramatic power-down)
        function playSuperweaponExpiredSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;

            // Descending power-down sweep
            const sweepOsc = audioCtx.createOscillator();
            const sweepGain = audioCtx.createGain();

            sweepOsc.connect(sweepGain);
            sweepGain.connect(audioCtx.destination);

            sweepOsc.type = 'sawtooth';
            sweepOsc.frequency.setValueAtTime(800, now);
            sweepOsc.frequency.exponentialRampToValueAtTime(100, now + 0.4);

            sweepGain.gain.setValueAtTime(0.15, now);
            sweepGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

            sweepOsc.start(now);
            sweepOsc.stop(now + 0.4);

            // Low thud at end
            const thudOsc = audioCtx.createOscillator();
            const thudGain = audioCtx.createGain();

            thudOsc.connect(thudGain);
            thudGain.connect(audioCtx.destination);

            thudOsc.type = 'sine';
            thudOsc.frequency.setValueAtTime(80, now + 0.3);
            thudOsc.frequency.exponentialRampToValueAtTime(40, now + 0.5);

            thudGain.gain.setValueAtTime(0.2, now + 0.3);
            thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

            thudOsc.start(now + 0.3);
            thudOsc.stop(now + 0.5);
        }

        function playShipExplosionSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            // Long dramatic explosion
            const now = audioCtx.currentTime;

            // Deep rumble layers
            [60, 80, 100, 120].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, now + i * 0.05);
                osc.frequency.exponentialRampToValueAtTime(15, now + 0.8);

                gain.gain.setValueAtTime(0.3, now + i * 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);

                osc.start(now + i * 0.05);
                osc.stop(now + 0.8);
            });

            // High frequency destruction
            [1000, 1500, 800, 1200].forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, now + i * 0.06);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.4);

                gain.gain.setValueAtTime(0.2, now + i * 0.06);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

                osc.start(now + i * 0.06);
                osc.stop(now + 0.4);
            });

            // Extended white noise
            const bufferSize = audioCtx.sampleRate * 0.6;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            noise.buffer = buffer;
            noise.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);

            noiseGain.gain.setValueAtTime(0.4, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);

            noise.start(now);
        }

        function playCrashSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            // Dramatic crash for earth impact
            const oscillator1 = audioCtx.createOscillator();
            const oscillator2 = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator1.connect(gainNode);
            oscillator2.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator1.type = 'sawtooth';
            oscillator2.type = 'square';

            oscillator1.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator1.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.4);

            oscillator2.frequency.setValueAtTime(180, audioCtx.currentTime);
            oscillator2.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.4);

            gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);

            oscillator1.start(audioCtx.currentTime);
            oscillator2.start(audioCtx.currentTime);
            oscillator1.stop(audioCtx.currentTime + 0.4);
            oscillator2.stop(audioCtx.currentTime + 0.4);
        }

        function playHitSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.15);

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        function playLevelCompleteSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            // Extended victory fanfare with harmonies
            const melody = [
                { freq: 523.25, dur: 0.15 }, // C
                { freq: 659.25, dur: 0.15 }, // E
                { freq: 783.99, dur: 0.15 }, // G
                { freq: 1046.50, dur: 0.3 }, // C (octave)
                { freq: 783.99, dur: 0.15 }, // G
                { freq: 1046.50, dur: 0.4 }  // C (hold)
            ];

            const chords = [
                [523.25, 659.25], // C-E
                [659.25, 783.99], // E-G
                [783.99, 1046.50], // G-C
                [523.25, 659.25, 1046.50], // C-E-C
                [392.00, 783.99], // G-G
                [523.25, 659.25, 1046.50]  // C-E-C (final)
            ];

            let time = 0;
            melody.forEach((note, i) => {
                // Melody
                const melOsc = audioCtx.createOscillator();
                const melGain = audioCtx.createGain();

                melOsc.connect(melGain);
                melGain.connect(audioCtx.destination);

                melOsc.type = 'square';
                melOsc.frequency.setValueAtTime(note.freq, audioCtx.currentTime + time);
                melGain.gain.setValueAtTime(0.25, audioCtx.currentTime + time);
                melGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + time + note.dur);

                melOsc.start(audioCtx.currentTime + time);
                melOsc.stop(audioCtx.currentTime + time + note.dur);

                // Harmony
                chords[i].forEach(freq => {
                    const chOsc = audioCtx.createOscillator();
                    const chGain = audioCtx.createGain();

                    chOsc.connect(chGain);
                    chGain.connect(audioCtx.destination);

                    chOsc.type = 'triangle';
                    chOsc.frequency.setValueAtTime(freq, audioCtx.currentTime + time);
                    chGain.gain.setValueAtTime(0.15, audioCtx.currentTime + time);
                    chGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + time + note.dur);

                    chOsc.start(audioCtx.currentTime + time);
                    chOsc.stop(audioCtx.currentTime + time + note.dur);
                });

                time += note.dur;
            });
        }

        // Background music - 6 different 32-bar melodies (5 classical + Med Ship theme)
        let musicPlaying = false;
        let musicTimeout = null;
        let activeOscillators = [];
        let currentMusicTrack = 0;

        async function startBackgroundMusic() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            // Stop any existing music first
            stopBackgroundMusic();

            musicPlaying = true;
            // Don't change track here - let nextWave() advance it sequentially
            playMusicLoop();
        }

        function stopBackgroundMusic() {
            musicPlaying = false;

            // Clear the timeout for next loop
            if (musicTimeout) {
                clearTimeout(musicTimeout);
                musicTimeout = null;
            }

            // Stop all active oscillators immediately
            activeOscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {
                    // Oscillator may have already stopped
                }
            });
            activeOscillators = [];
        }

        function playMusicLoop() {
            if (!musicPlaying || gameState.gameOver) return;

            // 6 different 32-bar themes (5 classical + 1 Med Ship)
            const musicTracks = [
                // Track 1: Ode to Joy (C major)
                [
                // Bar 1-2
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E (C-E)
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 698.46, chord: [523.25, 698.46], duration: 0.5 }, // F (C-F)
                { melody: 783.99, chord: [523.25, 783.99], duration: 0.5 }, // G (C-G)

                // Bar 3-4
                { melody: 783.99, chord: [523.25, 783.99], duration: 0.5 }, // G
                { melody: 698.46, chord: [523.25, 698.46], duration: 0.5 }, // F
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D (G-D)

                // Bar 5-6
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E

                // Bar 7-8
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.75 }, // E (hold)
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.25 }, // D
                { melody: 587.33, chord: [392.00, 587.33], duration: 1.0 }, // D (hold)

                // Bar 9-10 (repeat with variation)
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 698.46, chord: [523.25, 698.46], duration: 0.5 }, // F
                { melody: 783.99, chord: [523.25, 783.99], duration: 0.5 }, // G

                // Bar 11-12
                { melody: 783.99, chord: [523.25, 783.99], duration: 0.5 }, // G
                { melody: 698.46, chord: [523.25, 698.46], duration: 0.5 }, // F
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D

                // Bar 13-14
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E

                // Bar 15-16
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.75 }, // D (hold)
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.25 }, // C
                { melody: 523.25, chord: [523.25, 659.25], duration: 1.0 }, // C (hold)

                // Bar 17-18 (middle section - development)
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C

                // Bar 19-20
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 698.46, chord: [523.25, 698.46], duration: 0.5 }, // F
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E

                // Bar 21-22
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C

                // Bar 23-24
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.75 }, // D (hold)
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.25 }, // C
                { melody: 587.33, chord: [392.00, 587.33], duration: 1.0 }, // D (hold)

                // Bar 25-26 (return to main theme)
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 698.46, chord: [523.25, 698.46], duration: 0.5 }, // F
                { melody: 783.99, chord: [523.25, 783.99], duration: 0.5 }, // G

                // Bar 27-28
                { melody: 783.99, chord: [523.25, 783.99], duration: 0.5 }, // G
                { melody: 698.46, chord: [523.25, 698.46], duration: 0.5 }, // F
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D

                // Bar 29-30
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.5 }, // C
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.5 }, // D
                { melody: 659.25, chord: [523.25, 659.25], duration: 0.5 }, // E

                // Bar 31-32 (grand finale)
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.75 }, // D (hold)
                { melody: 523.25, chord: [523.25, 659.25], duration: 0.25 }, // C
                { melody: 523.25, chord: [523.25, 659.25, 783.99], duration: 1.5 }  // C (longer hold with full chord)
            ],

                // Track 2: Fur Elise inspired (A minor)
                [
                // Opening motif
                { melody: 659.25, chord: [440.00, 659.25], duration: 0.25 }, // E
                { melody: 622.25, chord: [415.30, 622.25], duration: 0.25 }, // D#
                { melody: 659.25, chord: [440.00, 659.25], duration: 0.25 }, // E
                { melody: 622.25, chord: [415.30, 622.25], duration: 0.25 }, // D#
                { melody: 659.25, chord: [440.00, 659.25], duration: 0.25 }, // E
                { melody: 493.88, chord: [329.63, 493.88], duration: 0.25 }, // B
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.25 }, // D
                { melody: 523.25, chord: [261.63, 523.25], duration: 0.25 }, // C
                { melody: 440.00, chord: [220.00, 440.00], duration: 0.5 }, // A (hold)
                { melody: 0, chord: [220.00], duration: 0.25 }, // rest
                { melody: 261.63, chord: [261.63, 329.63], duration: 0.25 }, // C
                { melody: 329.63, chord: [261.63, 329.63], duration: 0.25 }, // E
                { melody: 440.00, chord: [220.00, 440.00], duration: 0.25 }, // A
                { melody: 493.88, chord: [329.63, 493.88], duration: 0.5 }, // B (hold)
                { melody: 0, chord: [329.63], duration: 0.25 }, // rest
                { melody: 329.63, chord: [261.63, 329.63], duration: 0.25 }, // E
                { melody: 415.30, chord: [277.18, 415.30], duration: 0.25 }, // G#
                { melody: 493.88, chord: [329.63, 493.88], duration: 0.25 }, // B
                { melody: 523.25, chord: [261.63, 523.25], duration: 0.5 }, // C (hold)
                { melody: 0, chord: [261.63], duration: 0.25 }, // rest
                { melody: 329.63, chord: [261.63, 329.63], duration: 0.25 }, // E
                { melody: 659.25, chord: [440.00, 659.25], duration: 0.25 }, // E
                { melody: 622.25, chord: [415.30, 622.25], duration: 0.25 }, // D#
                { melody: 659.25, chord: [440.00, 659.25], duration: 0.25 }, // E
                { melody: 622.25, chord: [415.30, 622.25], duration: 0.25 }, // D#
                { melody: 659.25, chord: [440.00, 659.25], duration: 0.25 }, // E
                { melody: 493.88, chord: [329.63, 493.88], duration: 0.25 }, // B
                { melody: 587.33, chord: [392.00, 587.33], duration: 0.25 }, // D
                { melody: 523.25, chord: [261.63, 523.25], duration: 0.25 }, // C
                { melody: 440.00, chord: [220.00, 440.00], duration: 1.0 } // A (long hold)
            ],

                // Track 3: Canon in D inspired (D major)
                [
                // Pachelbel progression
                { melody: 587.33, chord: [293.66, 587.33], duration: 1.0 }, // D
                { melody: 440.00, chord: [220.00, 440.00], duration: 1.0 }, // A
                { melody: 493.88, chord: [246.94, 493.88], duration: 1.0 }, // B
                { melody: 369.99, chord: [369.99, 739.99], duration: 1.0 }, // F#
                { melody: 392.00, chord: [196.00, 392.00], duration: 1.0 }, // G
                { melody: 587.33, chord: [293.66, 587.33], duration: 1.0 }, // D
                { melody: 392.00, chord: [196.00, 392.00], duration: 1.0 }, // G
                { melody: 440.00, chord: [220.00, 440.00], duration: 1.0 }, // A
                // Development
                { melody: 587.33, chord: [293.66, 587.33], duration: 0.5 }, // D
                { melody: 698.46, chord: [293.66, 698.46], duration: 0.5 }, // F
                { melody: 739.99, chord: [369.99, 739.99], duration: 0.5 }, // F#
                { melody: 880.00, chord: [440.00, 880.00], duration: 0.5 }, // A
                { melody: 783.99, chord: [392.00, 783.99], duration: 0.5 }, // G
                { melody: 698.46, chord: [293.66, 698.46], duration: 0.5 }, // F
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.5 }, // E
                { melody: 587.33, chord: [293.66, 587.33], duration: 0.5 }, // D
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.5 }, // E
                { melody: 698.46, chord: [293.66, 698.46], duration: 0.5 }, // F
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.5 }, // E
                { melody: 587.33, chord: [293.66, 587.33], duration: 0.5 }, // D
                { melody: 493.88, chord: [246.94, 493.88], duration: 1.0 }, // B (hold)
                { melody: 440.00, chord: [220.00, 440.00], duration: 1.0 }, // A (hold)
                { melody: 587.33, chord: [293.66, 587.33, 880.00], duration: 2.0 } // D (final chord)
            ],

                // Track 4: Moonlight Sonata inspired (C# minor, dark)
                [
                // Triplet arpeggios
                { melody: 277.18, chord: [138.59, 277.18], duration: 0.33 }, // C#
                { melody: 415.30, chord: [138.59, 415.30], duration: 0.33 }, // G#
                { melody: 554.37, chord: [138.59, 554.37], duration: 0.33 }, // C#
                { melody: 277.18, chord: [138.59, 277.18], duration: 0.33 }, // C#
                { melody: 415.30, chord: [138.59, 415.30], duration: 0.33 }, // G#
                { melody: 554.37, chord: [138.59, 554.37], duration: 0.33 }, // C#
                { melody: 246.94, chord: [123.47, 246.94], duration: 0.33 }, // B
                { melody: 369.99, chord: [123.47, 369.99], duration: 0.33 }, // F#
                { melody: 493.88, chord: [123.47, 493.88], duration: 0.33 }, // B
                { melody: 246.94, chord: [123.47, 246.94], duration: 0.33 }, // B
                { melody: 369.99, chord: [123.47, 369.99], duration: 0.33 }, // F#
                { melody: 493.88, chord: [123.47, 493.88], duration: 0.33 }, // B
                { melody: 220.00, chord: [110.00, 220.00], duration: 0.33 }, // A
                { melody: 329.63, chord: [110.00, 329.63], duration: 0.33 }, // E
                { melody: 440.00, chord: [110.00, 440.00], duration: 0.33 }, // A
                { melody: 220.00, chord: [110.00, 220.00], duration: 0.33 }, // A
                { melody: 329.63, chord: [110.00, 329.63], duration: 0.33 }, // E
                { melody: 440.00, chord: [110.00, 440.00], duration: 0.33 }, // A
                { melody: 415.30, chord: [207.65, 415.30], duration: 0.33 }, // G#
                { melody: 554.37, chord: [207.65, 554.37], duration: 0.33 }, // C#
                { melody: 659.25, chord: [207.65, 659.25], duration: 0.33 }, // E
                { melody: 415.30, chord: [207.65, 415.30], duration: 0.33 }, // G#
                { melody: 554.37, chord: [207.65, 554.37], duration: 0.33 }, // C#
                { melody: 659.25, chord: [207.65, 659.25], duration: 0.33 }, // E
                { melody: 277.18, chord: [138.59, 277.18, 554.37], duration: 2.0 } // C# (final)
            ],

                // Track 5: Spring (Vivaldi inspired, bright E major)
                [
                // Energetic spring theme
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.25 }, // E
                { melody: 739.99, chord: [369.99, 739.99], duration: 0.25 }, // F#
                { melody: 830.61, chord: [415.30, 830.61], duration: 0.25 }, // G#
                { melody: 739.99, chord: [369.99, 739.99], duration: 0.25 }, // F#
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.5 }, // E
                { melody: 493.88, chord: [246.94, 493.88], duration: 0.25 }, // B
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.25 }, // E
                { melody: 493.88, chord: [246.94, 493.88], duration: 0.5 }, // B
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.25 }, // E
                { melody: 739.99, chord: [369.99, 739.99], duration: 0.25 }, // F#
                { melody: 830.61, chord: [415.30, 830.61], duration: 0.25 }, // G#
                { melody: 880.00, chord: [440.00, 880.00], duration: 0.25 }, // A
                { melody: 987.77, chord: [493.88, 987.77], duration: 0.5 }, // B
                { melody: 880.00, chord: [440.00, 880.00], duration: 0.25 }, // A
                { melody: 987.77, chord: [493.88, 987.77], duration: 0.25 }, // B
                { melody: 1108.73, chord: [554.37, 1108.73], duration: 0.5 }, // C#
                { melody: 987.77, chord: [493.88, 987.77], duration: 0.5 }, // B
                { melody: 880.00, chord: [440.00, 880.00], duration: 0.5 }, // A
                { melody: 830.61, chord: [415.30, 830.61], duration: 0.5 }, // G#
                { melody: 739.99, chord: [369.99, 739.99], duration: 0.5 }, // F#
                { melody: 659.25, chord: [329.63, 659.25], duration: 0.5 }, // E
                { melody: 493.88, chord: [246.94, 493.88], duration: 0.5 }, // B
                { melody: 659.25, chord: [329.63, 659.25, 987.77], duration: 1.5 } // E (final chord)
            ],
            // Track 6: Medical Ship Theme - Pulsing sci-fi bonus sound
            [
                // Pulsing low drone intro
                { melody: 130.81, chord: [65.41, 130.81], duration: 0.25 }, // C2
                { melody: 0, chord: [65.41], duration: 0.15 }, // Rest with bass
                { melody: 155.56, chord: [77.78, 155.56], duration: 0.25 }, // Eb2
                { melody: 0, chord: [77.78], duration: 0.15 }, // Rest with bass
                { melody: 174.61, chord: [87.31, 174.61], duration: 0.25 }, // F2
                { melody: 0, chord: [87.31], duration: 0.15 }, // Rest with bass
                { melody: 196.00, chord: [98.00, 196.00], duration: 0.4 }, // G2

                // Rising pulse pattern
                { melody: 261.63, chord: [130.81, 196.00], duration: 0.2 }, // C3
                { melody: 293.66, chord: [130.81, 196.00], duration: 0.2 }, // D3
                { melody: 311.13, chord: [155.56, 233.08], duration: 0.2 }, // Eb3
                { melody: 349.23, chord: [174.61, 261.63], duration: 0.2 }, // F3
                { melody: 392.00, chord: [196.00, 293.66], duration: 0.4 }, // G3

                // Spaceship hum with beacon pulses
                { melody: 523.25, chord: [261.63, 392.00], duration: 0.15 }, // C4 beacon
                { melody: 0, chord: [130.81, 196.00], duration: 0.2 }, // Hum
                { melody: 523.25, chord: [261.63, 392.00], duration: 0.15 }, // C4 beacon
                { melody: 0, chord: [130.81, 196.00], duration: 0.2 }, // Hum
                { melody: 622.25, chord: [311.13, 466.16], duration: 0.15 }, // Eb4 beacon
                { melody: 0, chord: [155.56, 233.08], duration: 0.2 }, // Hum
                { melody: 622.25, chord: [311.13, 466.16], duration: 0.15 }, // Eb4 beacon
                { melody: 0, chord: [155.56, 233.08], duration: 0.3 }, // Hum

                // Medical alert pattern (cross rhythm)
                { melody: 783.99, chord: [391.99, 523.25], duration: 0.1 }, // G4
                { melody: 698.46, chord: [349.23, 523.25], duration: 0.1 }, // F4
                { melody: 783.99, chord: [391.99, 523.25], duration: 0.1 }, // G4
                { melody: 0, chord: [196.00, 293.66], duration: 0.3 }, // Rest
                { melody: 783.99, chord: [391.99, 523.25], duration: 0.1 }, // G4
                { melody: 698.46, chord: [349.23, 523.25], duration: 0.1 }, // F4
                { melody: 783.99, chord: [391.99, 523.25], duration: 0.1 }, // G4
                { melody: 0, chord: [196.00, 293.66], duration: 0.4 }, // Rest

                // Deep pulse section
                { melody: 196.00, chord: [98.00, 146.83], duration: 0.3 }, // G2
                { melody: 0, chord: [98.00], duration: 0.1 },
                { melody: 196.00, chord: [98.00, 146.83], duration: 0.3 }, // G2
                { melody: 0, chord: [98.00], duration: 0.1 },
                { melody: 233.08, chord: [116.54, 174.61], duration: 0.3 }, // Bb2
                { melody: 0, chord: [116.54], duration: 0.1 },
                { melody: 261.63, chord: [130.81, 196.00], duration: 0.5 }, // C3

                // Rising beacon finale
                { melody: 392.00, chord: [196.00, 293.66], duration: 0.15 }, // G3
                { melody: 440.00, chord: [220.00, 329.63], duration: 0.15 }, // A3
                { melody: 493.88, chord: [246.94, 369.99], duration: 0.15 }, // B3
                { melody: 523.25, chord: [261.63, 392.00], duration: 0.15 }, // C4
                { melody: 587.33, chord: [293.66, 440.00], duration: 0.15 }, // D4
                { melody: 659.25, chord: [329.63, 493.88], duration: 0.15 }, // E4
                { melody: 698.46, chord: [349.23, 523.25], duration: 0.15 }, // F4
                { melody: 783.99, chord: [391.99, 587.33], duration: 0.6 }, // G4 hold

                // Repeat pulsing pattern
                { melody: 130.81, chord: [65.41, 130.81], duration: 0.25 }, // C2
                { melody: 0, chord: [65.41], duration: 0.15 },
                { melody: 155.56, chord: [77.78, 155.56], duration: 0.25 }, // Eb2
                { melody: 0, chord: [77.78], duration: 0.15 },
                { melody: 174.61, chord: [87.31, 174.61], duration: 0.25 }, // F2
                { melody: 0, chord: [87.31], duration: 0.15 },
                { melody: 196.00, chord: [98.00, 196.00, 293.66], duration: 0.8 } // G2 final
            ]
            ];

            const score = musicTracks[currentMusicTrack];

            let time = audioCtx.currentTime;
            let totalDuration = 0;

            score.forEach(note => {
                // Play melody line (skip if rest note)
                if (note.melody > 0) {
                    const melodyOsc = audioCtx.createOscillator();
                    const melodyGain = audioCtx.createGain();

                    melodyOsc.connect(melodyGain);
                    melodyGain.connect(audioCtx.destination);

                    melodyOsc.type = 'square';
                    melodyOsc.frequency.setValueAtTime(note.melody, time);
                    melodyGain.gain.setValueAtTime(0.05, time);
                    melodyGain.gain.exponentialRampToValueAtTime(0.01, time + note.duration);

                    melodyOsc.start(time);
                    melodyOsc.stop(time + note.duration);

                    // Track oscillator
                    activeOscillators.push(melodyOsc);
                }

                // Play chord (harmony)
                note.chord.forEach(freq => {
                    const chordOsc = audioCtx.createOscillator();
                    const chordGain = audioCtx.createGain();

                    chordOsc.connect(chordGain);
                    chordGain.connect(audioCtx.destination);

                    chordOsc.type = 'triangle';
                    chordOsc.frequency.setValueAtTime(freq, time);
                    chordGain.gain.setValueAtTime(0.02, time);
                    chordGain.gain.exponentialRampToValueAtTime(0.01, time + note.duration);

                    chordOsc.start(time);
                    chordOsc.stop(time + note.duration);

                    // Track oscillator
                    activeOscillators.push(chordOsc);
                });

                time += note.duration;
                totalDuration += note.duration;
            });

            // Loop the same track (don't advance until level changes)
            musicTimeout = setTimeout(playMusicLoop, totalDuration * 1000 + 300);
        }

        // Game state
        let gameState = {
            score: 0,
            wave: 1,
            earthHealth: 20,
            lives: 3,
            gameOver: false,
            victory: false,
            gameStarted: false,
            paused: false,
            exploding: false,
            explosionTimer: 0,
            player: {
                angle: 0,
                orbitRadius: 70,
                speed: 0.035,
                baseSpeed: 0.035,
                size: 12,
                bulletMode: 1,
                bulletSpeed: 3.75,
                shootCooldown: 0,
                shootCooldownTime: 20 // ~0.33s at 60fps (3 shots/sec)
            },
            bullets: [],
            aliens: [],
            powerUps: [],
            explosionParticles: [],
            alienSpawnTimer: 94, // Start ready to spawn immediately
            alienSpawnRate: 120, // Slower initial spawn
            bonusSpawnTimer: 0,
            bonusSpawnRate: 900, // Longer delay for bonus ships
            waveKills: 0,
            waveTarget: 8,
            keys: {},
            earthRotation: 0,
            mirrorShip: null,
            // Auto-fire system (5 second use, 5 second recharge)
            autoFireCharge: 300, // 5 seconds at 60fps
            autoFireMaxCharge: 300,
            autoFireAvailable: true,
            autoFireActive: false, // Currently firing
            medShip: null,
            medShipAppearedThisWave: false,
            medShipAppearances: 0,
            medPacks: [],
            // Superweapon spawn tracking (multiple per level on higher waves)
            superweaponSpawnsThisWave: 0,
            superweaponSpawnTargets: [], // Array of kill targets for each spawn
            // Life bonus spawn tracking (one per level, spawns between 50-75% kills)
            lifeBonusSpawnedThisWave: false,
            lifeBonusSpawnKillTarget: 0,
            // Superweapons system (count allows stacking multiple of same type)
            superweapons: {
                shield: { count: 0, key: null, active: false, timer: 0 },
                hyperkill: { count: 0, key: null },
                satellites: { count: 0, key: null, active: false, timer: 0 },
                quad: { count: 0, key: null, active: false, timer: 0 },
                rockets: { count: 0, key: null, active: false, timer: 0 }
            },
            activeSuperweapon: null,
            superweaponTimer: 0,
            superweaponCooldown: 0, // Prevents accidental trigger on pickup
            satellites: [], // For satellite positions
            quadShips: [], // For quad ship positions
            missiles: [], // For rocket barrage missiles
            missileFireTimer: 0,
            superweaponPickupsThisLevel: 0
        };

        // Alien types - loaded from JSON config
        let alienTypes;

        // Power-up types - loaded from JSON config
        let powerUpTypes;

        // Get available alien types based on wave (unlock one per level)
        function getAvailableAlienTypes() {
            if (!alienTypes || alienTypes.length === 0) return [];
            return alienTypes.filter(type => type.unlockLevel <= gameState.wave);
        }

        // Get current level config from JSON
        function getCurrentLevelConfig() {
            if (!gameConfig || !gameConfig.levels) return null;
            const levelConfig = gameConfig.levels.find(l => l.level === gameState.wave);
            return levelConfig || gameConfig.levels[gameConfig.levels.length - 1]; // Use last level as fallback
        }

        // Get spawn weights for alien types
        function getAlienSpawnWeights() {
            const available = getAvailableAlienTypes();
            const weights = [];

            available.forEach(type => {
                let weight = 10; // Base weight

                // Yellow invader always common (baseline)
                if (type.id === 'yellow_invader') {
                    weight = gameState.wave <= 5 ? 40 : gameState.wave <= 10 ? 25 : gameState.wave <= 15 ? 20 : 15;
                }
                // Bonus ships
                else if (type.isBonus) {
                    weight = 5;
                }
                // Fast single-hit enemies
                else if (type.health === 1 && type.baseSpeed >= 0.7) {
                    weight = 15;
                }
                // Heavy multi-hit enemies
                else if (type.health >= 3) {
                    weight = gameState.wave >= 15 ? 15 : 10;
                }
                // Kamikaze (high priority)
                else if (type.id === 'orange_kamikaze') {
                    weight = gameState.wave >= 14 ? 10 : 5;
                }
                // Black boss (rare but terrifying)
                else if (type.id === 'black_boss') {
                    weight = 3;
                }

                weights.push({ type, weight });
            });

            return weights;
        }

        // Select random alien type based on weights
        function selectRandomAlienType() {
            const weights = getAlienSpawnWeights();
            if (weights.length === 0) return null;

            const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
            let random = Math.random() * totalWeight;

            for (let w of weights) {
                random -= w.weight;
                if (random <= 0) return w.type;
            }

            return weights[0].type;
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            // Resume audio context on first interaction (browser requirement)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            // Handle start game
            if ((e.key === 'p' || e.key === 'P') && !gameState.gameStarted) {
                startGame();
                return;
            }

            // Handle pause
            if (e.key === 'Enter') {
                if (!gameState.gameOver && !gameState.exploding) {
                    togglePause();
                }
                return;
            }
            // Handle sound toggle
            if (e.key === 'Delete' || e.key === 'Backspace') {
                toggleSound();
                return;
            }
            // Handle level chooser
            if (e.key === '=') {
                openLevelChooser();
                return;
            }
            // Handle config
            if ((e.key === 'c' || e.key === 'C') && !gameState.gameStarted) {
                openConfig();
                return;
            }
            if (e.key === 'Escape') {
                closeLevelChooser();
                closeConfig();
                return;
            }
            gameState.keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        // Toggle pause
        function togglePause() {
            gameState.paused = !gameState.paused;
            const pauseMsg = document.getElementById('pauseMessage');

            if (gameState.paused) {
                pauseMsg.classList.add('show');
                stopBackgroundMusic();
            } else {
                pauseMsg.classList.remove('show');
                startBackgroundMusic();
            }
        }

        // Level chooser state
        let selectedLoadout = 'fresh';

        // Open level chooser
        function openLevelChooser() {
            const chooser = document.getElementById('levelChooser');
            chooser.classList.add('show');
            gameState.paused = true;
            stopBackgroundMusic();
        }

        // Close level chooser
        function closeLevelChooser() {
            const chooser = document.getElementById('levelChooser');
            chooser.classList.remove('show');
            if (gameState.gameStarted && !gameState.gameOver) {
                gameState.paused = false;
                startBackgroundMusic();
            }
        }

        // Store default config for reset
        let defaultGameConfig = null;

        // Custom config multipliers (applied on top of base config)
        let customConfig = {
            enemySpeedMult: 1,
            enemyHealthMult: 1,
            pointsMult: 1,
            baseSpawnRate: 90,
            powerupChance: 35,
            superweaponDuration: 10,
            superweaponUnlock: 5,
            shieldRadius: 150,
            satelliteRadius: 200,
            missileDamage: 2,
            mirrorDuration: 30,
            extraLifePoints: 10000
        };

        // Open config modal
        function openConfig() {
            // Store defaults on first open
            if (!defaultGameConfig) {
                defaultGameConfig = JSON.parse(JSON.stringify(gameConfig));
            }

            const modal = document.getElementById('configModal');
            modal.classList.add('show');
            populateConfigForm();
        }

        // Close config modal
        function closeConfig() {
            document.getElementById('configModal').classList.remove('show');
        }

        // Show config tab
        function showConfigTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.config-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Show corresponding section
            document.querySelectorAll('.config-section').forEach(section => {
                section.classList.remove('active');
            });
            document.getElementById('config-' + tabName).classList.add('active');
        }

        // Populate form from gameConfig
        function populateConfigForm() {
            const p = gameConfig.player;

            // Player settings
            document.getElementById('cfg-startingLives').value = p.startingLives;
            document.getElementById('cfg-maxLives').value = p.maxLives;
            document.getElementById('cfg-startingEarthHealth').value = p.startingEarthHealth;
            document.getElementById('cfg-maxEarthHealth').value = p.maxEarthHealth;
            document.getElementById('cfg-shipSize').value = p.shipSize;
            document.getElementById('cfg-orbitRadius').value = p.orbitRadius;

            // Combat settings
            document.getElementById('cfg-startingRotationSpeed').value = p.startingRotationSpeed;
            document.getElementById('cfg-maxRotationSpeed').value = p.maxRotationSpeed;
            document.getElementById('cfg-startingFireRate').value = p.startingFireRate;
            document.getElementById('cfg-minFireRate').value = p.minFireRate;
            document.getElementById('cfg-startingBulletSpeed').value = p.startingBulletSpeed;
            document.getElementById('cfg-maxBulletSpeed').value = p.maxBulletSpeed;
            document.getElementById('cfg-maxBulletMode').value = p.maxBulletMode;

            // Enemy settings (custom multipliers)
            document.getElementById('cfg-baseSpawnRate').value = customConfig.baseSpawnRate;
            document.getElementById('cfg-enemySpeedMult').value = customConfig.enemySpeedMult;
            document.getElementById('cfg-enemyHealthMult').value = customConfig.enemyHealthMult;
            document.getElementById('cfg-pointsMult').value = customConfig.pointsMult;

            // Power-up settings
            document.getElementById('cfg-powerupChance').value = customConfig.powerupChance;
            document.getElementById('cfg-mirrorDuration').value = customConfig.mirrorDuration;
            document.getElementById('cfg-speedIncrement').value = p.rotationSpeedIncrement;
            document.getElementById('cfg-extraLifePoints').value = customConfig.extraLifePoints;

            // Superweapon settings
            document.getElementById('cfg-superweaponDuration').value = customConfig.superweaponDuration;
            document.getElementById('cfg-superweaponUnlock').value = customConfig.superweaponUnlock;
            document.getElementById('cfg-shieldRadius').value = customConfig.shieldRadius;
            document.getElementById('cfg-satelliteRadius').value = customConfig.satelliteRadius;
            document.getElementById('cfg-missileDamage').value = customConfig.missileDamage;
        }

        // Save config from form
        function saveConfig() {
            const p = gameConfig.player;

            // Player settings
            p.startingLives = parseInt(document.getElementById('cfg-startingLives').value);
            p.maxLives = parseInt(document.getElementById('cfg-maxLives').value);
            p.startingEarthHealth = parseInt(document.getElementById('cfg-startingEarthHealth').value);
            p.maxEarthHealth = parseInt(document.getElementById('cfg-maxEarthHealth').value);
            p.shipSize = parseInt(document.getElementById('cfg-shipSize').value);
            p.orbitRadius = parseInt(document.getElementById('cfg-orbitRadius').value);

            // Combat settings
            p.startingRotationSpeed = parseFloat(document.getElementById('cfg-startingRotationSpeed').value);
            p.maxRotationSpeed = parseFloat(document.getElementById('cfg-maxRotationSpeed').value);
            p.startingFireRate = parseInt(document.getElementById('cfg-startingFireRate').value);
            p.minFireRate = parseInt(document.getElementById('cfg-minFireRate').value);
            p.startingBulletSpeed = parseInt(document.getElementById('cfg-startingBulletSpeed').value);
            p.maxBulletSpeed = parseInt(document.getElementById('cfg-maxBulletSpeed').value);
            p.maxBulletMode = parseInt(document.getElementById('cfg-maxBulletMode').value);

            // Enemy settings (custom multipliers)
            customConfig.baseSpawnRate = parseInt(document.getElementById('cfg-baseSpawnRate').value);
            customConfig.enemySpeedMult = parseFloat(document.getElementById('cfg-enemySpeedMult').value);
            customConfig.enemyHealthMult = parseFloat(document.getElementById('cfg-enemyHealthMult').value);
            customConfig.pointsMult = parseFloat(document.getElementById('cfg-pointsMult').value);

            // Power-up settings
            customConfig.powerupChance = parseInt(document.getElementById('cfg-powerupChance').value);
            customConfig.mirrorDuration = parseInt(document.getElementById('cfg-mirrorDuration').value);
            p.rotationSpeedIncrement = parseFloat(document.getElementById('cfg-speedIncrement').value);
            customConfig.extraLifePoints = parseInt(document.getElementById('cfg-extraLifePoints').value);

            // Superweapon settings
            customConfig.superweaponDuration = parseInt(document.getElementById('cfg-superweaponDuration').value);
            customConfig.superweaponUnlock = parseInt(document.getElementById('cfg-superweaponUnlock').value);
            customConfig.shieldRadius = parseInt(document.getElementById('cfg-shieldRadius').value);
            customConfig.satelliteRadius = parseInt(document.getElementById('cfg-satelliteRadius').value);
            customConfig.missileDamage = parseInt(document.getElementById('cfg-missileDamage').value);

            // Apply enemy multipliers to alien types
            applyEnemyMultipliers();

            closeConfig();
        }

        // Apply enemy multipliers
        function applyEnemyMultipliers() {
            if (!defaultGameConfig) return;

            alienTypes.forEach((alien, i) => {
                const defaultAlien = defaultGameConfig.alienTypes[i];
                if (defaultAlien) {
                    alien.speed = defaultAlien.speed * customConfig.enemySpeedMult;
                    alien.health = Math.ceil(defaultAlien.health * customConfig.enemyHealthMult);
                    alien.points = Math.round(defaultAlien.points * customConfig.pointsMult);
                }
            });
        }

        // Reset config to defaults
        function resetConfigToDefaults() {
            if (defaultGameConfig) {
                gameConfig.player = JSON.parse(JSON.stringify(defaultGameConfig.player));
                alienTypes = JSON.parse(JSON.stringify(defaultGameConfig.alienTypes));
            }

            customConfig = {
                enemySpeedMult: 1,
                enemyHealthMult: 1,
                pointsMult: 1,
                baseSpawnRate: 90,
                powerupChance: 35,
                superweaponDuration: 10,
                superweaponUnlock: 5,
                shieldRadius: 150,
                satelliteRadius: 200,
                missileDamage: 2,
                mirrorDuration: 30,
                extraLifePoints: 10000
            };

            populateConfigForm();
        }

        // Apply difficulty presets
        function applyPreset(preset) {
            resetConfigToDefaults();

            const p = gameConfig.player;

            switch (preset) {
                case 'easy':
                    p.startingLives = 5;
                    p.startingEarthHealth = 30;
                    customConfig.enemySpeedMult = 0.7;
                    customConfig.enemyHealthMult = 0.7;
                    customConfig.pointsMult = 0.5;
                    customConfig.baseSpawnRate = 120;
                    customConfig.powerupChance = 50;
                    break;

                case 'normal':
                    // Default values - already reset
                    break;

                case 'hard':
                    p.startingLives = 2;
                    p.startingEarthHealth = 15;
                    customConfig.enemySpeedMult = 1.3;
                    customConfig.enemyHealthMult = 1.5;
                    customConfig.pointsMult = 2;
                    customConfig.baseSpawnRate = 60;
                    customConfig.powerupChance = 25;
                    break;

                case 'insane':
                    p.startingLives = 1;
                    p.startingEarthHealth = 10;
                    customConfig.enemySpeedMult = 1.8;
                    customConfig.enemyHealthMult = 2;
                    customConfig.pointsMult = 5;
                    customConfig.baseSpawnRate = 40;
                    customConfig.powerupChance = 15;
                    customConfig.superweaponDuration = 5;
                    break;
            }

            applyEnemyMultipliers();
            populateConfigForm();
        }

        // Select loadout
        function selectLoadout(type) {
            selectedLoadout = type;
            // Update button visuals
            document.querySelectorAll('.loadout-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.getElementById(`loadout-${type}`).classList.add('selected');
        }

        // Jump to wave with loadout
        function jumpToWave(waveNum) {
            closeLevelChooser();

            // Set wave
            gameState.wave = waveNum;
            gameState.waveKills = 0;
            gameState.lastBonusKillCount = 0;

            // Reset lives, earth health, and score
            gameState.lives = gameConfig.player.startingLives;
            gameState.earthHealth = gameConfig.player.startingEarthHealth;
            gameState.score = 0;

            // Get wave target from level config
            const levelConfig = getCurrentLevelConfig();
            gameState.waveTarget = levelConfig ? levelConfig.aliensToKill : 8;

            // Reset superweapon spawn tracking (multiple spawns on higher levels)
            gameState.superweaponSpawnsThisWave = 0;
            gameState.superweaponSpawnTargets = [];
            if (waveNum >= 5) {
                // Determine how many superweapons spawn this wave
                let numSpawns = 1;
                if (waveNum >= 15) numSpawns = 3;
                else if (waveNum >= 10) numSpawns = 2;

                // Set kill targets spread across the wave
                for (let i = 0; i < numSpawns; i++) {
                    const startPercent = 0.20 + (i * 0.25); // 20%, 45%, 70%
                    const endPercent = startPercent + 0.15;
                    const minKills = Math.floor(gameState.waveTarget * startPercent);
                    const maxKills = Math.floor(gameState.waveTarget * endPercent);
                    gameState.superweaponSpawnTargets.push(minKills + Math.floor(Math.random() * (maxKills - minKills + 1)));
                }
            }

            // Reset life bonus spawn tracking (spawns at 50-75% of kills)
            gameState.lifeBonusSpawnedThisWave = false;
            const lifeMinKills = Math.floor(gameState.waveTarget * 0.50);
            const lifeMaxKills = Math.floor(gameState.waveTarget * 0.75);
            gameState.lifeBonusSpawnKillTarget = lifeMinKills + Math.floor(Math.random() * (lifeMaxKills - lifeMinKills + 1));

            // Clear all entities
            gameState.aliens = [];
            gameState.bullets = [];
            gameState.powerUps = [];
            gameState.explosionParticles = [];
            gameState.medPacks = [];

            // Reset temporary power-ups
            gameState.mirrorShip = null;
            gameState.medShip = null;
            gameState.medShipAppearedThisWave = false;
            gameState.medShipAppearances = 0;
            resetSuperweapons();

            // Apply loadout using config values
            const cfg = gameConfig.player;
            if (selectedLoadout === 'fresh') {
                // Base stats from config
                gameState.player.speed = cfg.startingRotationSpeed;
                gameState.player.baseSpeed = cfg.startingRotationSpeed;
                gameState.player.bulletMode = cfg.startingBulletMode;
                gameState.player.bulletSpeed = cfg.startingBulletSpeed;
                gameState.player.shootCooldownTime = cfg.startingFireRate;
            } else if (selectedLoadout === 'mid') {
                // Mid-game (~Wave 10) - 5 upgrades of each
                gameState.player.speed = cfg.startingRotationSpeed + (5 * cfg.rotationSpeedIncrement);
                gameState.player.baseSpeed = gameState.player.speed;
                gameState.player.bulletMode = 3; // Triple shot
                gameState.player.bulletSpeed = cfg.startingBulletSpeed + (5 * cfg.bulletSpeedIncrement);
                gameState.player.shootCooldownTime = cfg.startingFireRate + (5 * cfg.fireRateIncrement);
            } else if (selectedLoadout === 'late') {
                // Late-game (~Wave 16) - maxed stats
                gameState.player.speed = cfg.maxRotationSpeed;
                gameState.player.baseSpeed = gameState.player.speed;
                gameState.player.bulletMode = cfg.maxBulletMode;
                gameState.player.bulletSpeed = cfg.maxBulletSpeed;
                gameState.player.shootCooldownTime = cfg.minFireRate;
            }

            // Give all superweapons when using level chooser
            giveSuperweapon('hyperkill');
            giveSuperweapon('shield');
            giveSuperweapon('satellites');
            giveSuperweapon('quad');
            giveSuperweapon('rockets');

            // Reset cooldown and player position
            gameState.player.shootCooldown = 0;
            gameState.player.angle = 0;

            // Reset auto-fire to full charge
            gameState.autoFireCharge = gameState.autoFireMaxCharge;
            gameState.autoFireAvailable = true;
            gameState.autoFireActive = false;
            updateAutoFireUI();

            // Start game if not started
            if (!gameState.gameStarted) {
                gameState.gameStarted = true;
                document.getElementById('startScreen').classList.add('hidden');
            }

            // Unpause and start music
            gameState.paused = false;
            gameState.exploding = false;
            gameState.explosionTimer = 0;
            gameState.gameOver = false;
            document.getElementById('gameOver').classList.remove('show');

            // Set music track based on wave (cycle through classical tracks)
            currentMusicTrack = (waveNum - 1) % 5;
            startBackgroundMusic();

            // Update UI
            updateUI();

            // Show wave message
            showLevelMessage(`WAVE ${gameState.wave}`);
        }

        // Draw Earth with better graphics (reduced rotation to minimize flashing)
        function drawEarth() {
            ctx.save();
            gameState.earthRotation += 0.0003; // Slower rotation

            // Space around Earth glow (static - no gradient recalculation)
            ctx.fillStyle = 'rgba(100, 150, 255, 0.15)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 55, 0, Math.PI * 2);
            ctx.fill();

            // Ocean (base) - solid colors to prevent gradient flashing
            ctx.fillStyle = '#1E90FF';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 35, 0, Math.PI * 2);
            ctx.fill();

            // Ocean shading (simple)
            ctx.fillStyle = '#5CB3FF';
            ctx.beginPath();
            ctx.arc(centerX - 8, centerY - 8, 20, 0, Math.PI * 2);
            ctx.fill();

            // Continents (more earthy green-brown tones)
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(gameState.earthRotation);

            // Use multiple shades for depth
            ctx.fillStyle = '#4d7c29'; // Medium green

            // Americas (western hemisphere)
            ctx.fillRect(-22, -18, 10, 6); // North America top
            ctx.fillRect(-20, -13, 12, 8); // North America main
            ctx.fillRect(-16, -6, 6, 5);   // Central America
            ctx.fillRect(-14, 1, 8, 4);    // Northern South America
            ctx.fillRect(-12, 5, 7, 10);   // South America

            // Africa/Europe (center-left)
            ctx.fillRect(-6, -22, 8, 6);   // Northern Europe
            ctx.fillRect(-8, -17, 10, 12); // Western Europe & North Africa
            ctx.fillRect(-4, -6, 12, 16);  // Central & Southern Africa
            ctx.fillRect(4, -2, 6, 8);     // East Africa

            // Asia (eastern hemisphere)
            ctx.fillRect(6, -20, 12, 8);   // Northern Asia
            ctx.fillRect(10, -13, 14, 10); // Central Asia
            ctx.fillRect(14, -4, 10, 8);   // Southeast Asia

            // Australia
            ctx.fillRect(16, 6, 10, 7);

            // Add darker lowlands
            ctx.fillStyle = '#3a5f1f';
            ctx.fillRect(-20, -11, 4, 3); // North America detail
            ctx.fillRect(-6, -8, 4, 4);   // Africa detail
            ctx.fillRect(12, -11, 5, 4);  // Asia detail

            // Add lighter highlands
            ctx.fillStyle = '#6b9940';
            ctx.fillRect(-18, -16, 3, 2); // Mountains
            ctx.fillRect(-2, -19, 3, 2);  // Alps
            ctx.fillRect(8, -18, 4, 2);   // Himalayas

            ctx.restore();

            // Clouds (static, no rotation to reduce flashing)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX - 18, centerY - 10, 5, 0, Math.PI * 2);
            ctx.arc(centerX - 8, centerY - 20, 4, 0, Math.PI * 2);
            ctx.arc(centerX + 10, centerY + 2, 6, 0, Math.PI * 2);
            ctx.arc(centerX + 15, centerY - 12, 5, 0, Math.PI * 2);
            ctx.fill();

            // Atmosphere glow (single color, no gradient)
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 37, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        // Create alien explosion particles
        function createAlienExplosion(x, y, alienType) {
            const particleCount = alienType.name === 'large' ? 20 : alienType.name === 'medium' ? 15 : 10;
            const colors = alienType.isBonus ? ['#00ffff', '#ffff00'] : [alienType.color, alienType.secondaryColor, '#ffaa00'];

            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + (Math.random() - 0.5) * 0.5;
                const speed = Math.random() * 2 + 1;
                gameState.explosionParticles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30,
                    maxLife: 30,
                    size: Math.random() * 3 + 1,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
        }

        // Update explosion particles
        function updateExplosionParticles() {
            gameState.explosionParticles = gameState.explosionParticles.filter(particle => {
                particle.x += particle.vx * deltaTime;
                particle.y += particle.vy * deltaTime;
                particle.life -= deltaTime;

                // Fade and slow down
                const slowdownRate = Math.pow(0.95, deltaTime);
                particle.vx *= slowdownRate;
                particle.vy *= slowdownRate;

                return particle.life > 0;
            });

            if (gameState.exploding) {
                gameState.explosionTimer -= deltaTime;
                if (gameState.explosionTimer <= 0) {
                    gameState.exploding = false;
                }
            }
        }

        // Draw explosion particles
        function drawExplosionParticles() {
            gameState.explosionParticles.forEach(particle => {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = alpha;

                ctx.fillRect(
                    particle.x - particle.size / 2,
                    particle.y - particle.size / 2,
                    particle.size,
                    particle.size
                );

                ctx.globalAlpha = 1;
            });
        }

        // Draw 8-bit style player ship (with power-up visual enhancements)
        function drawPlayer() {
            if (gameState.exploding) return; // Don't draw ship during explosion

            const x = centerX + Math.cos(gameState.player.angle) * gameState.player.orbitRadius;
            const y = centerY + Math.sin(gameState.player.angle) * gameState.player.orbitRadius;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(gameState.player.angle + Math.PI / 2);

            // Calculate size scaling based on power-ups
            let sizeMultiplier = 1.0;
            const speedUpgrades = Math.floor((gameState.player.speed - gameConfig.player.startingRotationSpeed) / gameConfig.player.rotationSpeedIncrement);
            sizeMultiplier += speedUpgrades * 0.02; // Grow with speed
            if (gameState.player.bulletMode >= 3) sizeMultiplier += 0.15;
            if (gameState.player.bulletMode >= 5) sizeMultiplier += 0.15;

            const s = gameState.player.size * sizeMultiplier;

            // Determine colors based on power-ups
            let mainColor, highlightColor, accentColor;
            if (gameState.player.bulletMode === 5) {
                // Quintuple - Red/Orange theme
                mainColor = '#ff0000';
                highlightColor = '#ff8800';
                accentColor = '#ffff00';
            } else if (gameState.player.bulletMode === 3) {
                // Triple - Blue/Cyan theme
                mainColor = '#0088ff';
                highlightColor = '#00ffff';
                accentColor = '#88ffff';
            } else if (gameState.player.bulletMode === 2) {
                // Double - Purple theme
                mainColor = '#8800ff';
                highlightColor = '#aa88ff';
                accentColor = '#ff00ff';
            } else {
                // Single - Green theme (default)
                mainColor = '#00ff00';
                highlightColor = '#88ff88';
                accentColor = '#00ffaa';
            }

            // Nose (main color)
            ctx.fillStyle = mainColor;
            ctx.fillRect(-2, -s, 4, 4);

            // Nose tip highlight
            ctx.fillStyle = highlightColor;
            ctx.fillRect(-1, -s, 2, 2);

            // Main body
            ctx.fillStyle = mainColor;
            ctx.fillRect(-4, -s + 4, 8, 8);

            // Body highlight
            ctx.fillStyle = highlightColor;
            ctx.fillRect(-3, -s + 5, 2, 2);
            ctx.fillRect(1, -s + 5, 2, 2);

            // Wings (larger if powered up)
            const wingSize = gameState.player.bulletMode >= 3 ? 1.2 : 1.0;
            ctx.fillStyle = mainColor;
            ctx.fillRect(-8 * wingSize, -s + 8, 4 * wingSize, 6);
            ctx.fillRect(4 * wingSize, -s + 8, 4 * wingSize, 6);

            // Wing details
            ctx.fillStyle = accentColor;
            ctx.fillRect(-7 * wingSize, -s + 9, 2, 2);
            ctx.fillRect(5 * wingSize, -s + 9, 2, 2);

            // Additional weapon pods for x3 and x5
            if (gameState.player.bulletMode >= 3) {
                ctx.fillStyle = accentColor;
                ctx.fillRect(-10 * wingSize, -s + 6, 2, 4);
                ctx.fillRect(8 * wingSize, -s + 6, 2, 4);
            }
            if (gameState.player.bulletMode === 5) {
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-11 * wingSize, -s + 4, 2, 3);
                ctx.fillRect(9 * wingSize, -s + 4, 2, 3);
            }

            // Cockpit
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-2, -s + 6, 4, 3);

            // Cockpit window
            ctx.fillStyle = '#0088ff';
            ctx.fillRect(-1, -s + 7, 2, 1);

            // Engine glow (enhanced when auto-firing)
            const engineColor = gameState.autoFireActive ? '#ff0000' : '#ffff00';
            const engineSize = gameState.autoFireActive ? 1.3 : 1.0;
            ctx.fillStyle = engineColor;
            ctx.fillRect(-3, s - 3 * engineSize, 2, 3 * engineSize);
            ctx.fillRect(1, s - 3 * engineSize, 2, 3 * engineSize);

            // Engine core (bright)
            ctx.fillStyle = gameState.autoFireActive ? '#ffff00' : '#ffaa00';
            ctx.fillRect(-3, s - 2, 2, 2);
            ctx.fillRect(1, s - 2, 2, 2);

            // Speed trails (if fast)
            if (speedUpgrades >= 5) {
                ctx.fillStyle = mainColor;
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-2, s, 4, 4);
                ctx.fillRect(-1, s + 4, 2, 3);
                ctx.globalAlpha = 1.0;
            }

            ctx.restore();
        }

        // Draw 8-bit alien ships
        function draw8BitAlien(x, y, alienType) {
            const size = alienType.size;
            const color = alienType.color;
            const secondaryColor = alienType.secondaryColor;
            const shape = alienType.shape;
            const s = size;

            ctx.save();
            ctx.translate(x, y);

            if (shape === 'invader1') {
                // Classic space invader small - yellow/orange
                // Main body
                ctx.fillStyle = color;
                ctx.fillRect(-s, -s * 0.5, s * 2, s * 0.5);
                ctx.fillRect(-s * 0.7, -s, s * 1.4, s * 0.5);

                // Legs
                ctx.fillRect(-s * 1.2, 0, s * 0.6, s * 0.5);
                ctx.fillRect(s * 0.6, 0, s * 0.6, s * 0.5);
                ctx.fillRect(-s * 0.4, s * 0.5, s * 0.3, s * 0.3);
                ctx.fillRect(s * 0.1, s * 0.5, s * 0.3, s * 0.3);

                // Details in secondary color
                ctx.fillStyle = secondaryColor;
                ctx.fillRect(-s * 0.4, -s * 0.3, s * 0.3, s * 0.3);
                ctx.fillRect(s * 0.1, -s * 0.3, s * 0.3, s * 0.3);

                // Eyes
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-s * 0.5, -s * 0.6, s * 0.2, s * 0.2);
                ctx.fillRect(s * 0.3, -s * 0.6, s * 0.2, s * 0.2);
            } else if (shape === 'invader2') {
                // Medium UFO style - orange/red
                // Main saucer body
                ctx.fillStyle = color;
                ctx.fillRect(-s * 1.2, -s * 0.3, s * 2.4, s * 0.6);

                // Dome
                ctx.fillRect(-s * 0.8, -s * 0.8, s * 1.6, s * 0.5);

                // Landing gear
                ctx.fillRect(-s * 1.5, 0, s * 0.5, s * 0.4);
                ctx.fillRect(-s * 0.5, 0, s * 0.5, s * 0.4);
                ctx.fillRect(s * 0.5, 0, s * 0.5, s * 0.4);
                ctx.fillRect(s * 1, 0, s * 0.5, s * 0.4);

                // Dome details
                ctx.fillStyle = secondaryColor;
                ctx.fillRect(-s * 0.6, -s * 0.6, s * 1.2, s * 0.3);

                // Windows
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-s * 0.5, -s * 0.5, s * 0.3, s * 0.2);
                ctx.fillRect(s * 0.2, -s * 0.5, s * 0.3, s * 0.2);

                // Lights on body
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-s * 0.9, -s * 0.1, s * 0.2, s * 0.2);
                ctx.fillRect(s * 0.7, -s * 0.1, s * 0.2, s * 0.2);
            } else if (shape === 'invader3') {
                // Large boss style - red/dark red
                // Main body
                ctx.fillStyle = color;
                ctx.fillRect(-s * 1.3, -s * 0.8, s * 2.6, s * 1.2);

                // Command bridge
                ctx.fillRect(-s * 0.9, -s * 1.3, s * 1.8, s * 0.6);

                // Side cannons
                ctx.fillRect(-s * 1.6, -s * 0.3, s * 0.6, s * 0.8);
                ctx.fillRect(s * 1, -s * 0.3, s * 0.6, s * 0.8);

                // Engine thrusters
                ctx.fillRect(-s * 0.6, s * 0.4, s * 0.4, s * 0.5);
                ctx.fillRect(s * 0.2, s * 0.4, s * 0.4, s * 0.5);

                // Body details
                ctx.fillStyle = secondaryColor;
                ctx.fillRect(-s * 1.1, -s * 0.6, s * 0.5, s * 0.4);
                ctx.fillRect(s * 0.6, -s * 0.6, s * 0.5, s * 0.4);
                ctx.fillRect(-s * 0.4, -s * 0.3, s * 0.8, s * 0.4);

                // Cannon tips
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-s * 1.6, -s * 0.1, s * 0.3, s * 0.2);
                ctx.fillRect(s * 1.3, -s * 0.1, s * 0.3, s * 0.2);

                // Eyes/sensors
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-s * 0.5, -s * 0.9, s * 0.3, s * 0.3);
                ctx.fillRect(s * 0.2, -s * 0.9, s * 0.3, s * 0.3);

                // Engine glow
                ctx.fillStyle = '#ff8800';
                ctx.fillRect(-s * 0.6, s * 0.6, s * 0.4, s * 0.3);
                ctx.fillRect(s * 0.2, s * 0.6, s * 0.4, s * 0.3);
            } else if (shape === 'bonus') {
                // Bonus ship - cyan saucer with animations
                // Main body (diamond shape)
                ctx.fillStyle = color;
                ctx.fillRect(-s * 1.1, -s * 0.2, s * 2.2, s * 0.4);
                ctx.fillRect(-s * 0.8, -s * 0.5, s * 1.6, s * 0.3);
                ctx.fillRect(-s * 0.8, s * 0.2, s * 1.6, s * 0.3);

                // Core
                ctx.fillStyle = secondaryColor;
                ctx.fillRect(-s * 0.5, -s * 0.3, s, s * 0.6);

                // Flashing lights
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-s * 1.0, -s * 0.1, s * 0.2, s * 0.2);
                ctx.fillRect(s * 0.8, -s * 0.1, s * 0.2, s * 0.2);

                // Star symbol (indicates power-up)
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-s * 0.1, -s * 0.4, s * 0.2, s * 0.8);
                ctx.fillRect(-s * 0.4, -s * 0.1, s * 0.8, s * 0.2);
            } else {
                // Default shape for any unspecified shapes (simple square alien)
                ctx.fillStyle = color;
                ctx.fillRect(-s, -s, s * 2, s * 2);
                ctx.fillStyle = secondaryColor;
                ctx.fillRect(-s * 0.5, -s * 0.5, s, s);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-s * 0.3, -s * 0.6, s * 0.2, s * 0.2);
                ctx.fillRect(s * 0.1, -s * 0.6, s * 0.2, s * 0.2);
            }

            ctx.restore();
        }

        // Update player
        function updatePlayer() {
            if (gameState.paused || gameState.exploding) return;

            // Decrement shoot cooldown
            if (gameState.player.shootCooldown > 0) {
                gameState.player.shootCooldown -= deltaTime;
            }

            if (gameState.keys['q']) {
                gameState.player.angle -= gameState.player.speed * deltaTime;
            }
            if (gameState.keys['a']) {
                gameState.player.angle += gameState.player.speed * deltaTime;
            }
            // Auto-fire charge/recharge system
            const autoFireDisabled = gameState.wave <= 3; // Disabled for first 3 levels

            if (gameState.keys['p']) {
                if (!autoFireDisabled && gameState.autoFireAvailable && gameState.autoFireCharge > 0) {
                    // Auto-fire mode: continuous shooting while held, depletes charge
                    gameState.autoFireActive = true;
                    shoot();
                    gameState.autoFireCharge -= deltaTime;
                    if (gameState.autoFireCharge <= 0) {
                        gameState.autoFireCharge = 0;
                        gameState.autoFireAvailable = false;
                        gameState.autoFireActive = false;
                    }
                } else {
                    // Manual fire mode (single shot, release key to fire again)
                    gameState.autoFireActive = false;
                    shoot();
                    gameState.keys['p'] = false;
                }
            } else {
                gameState.autoFireActive = false;
                // Recharge when not firing (at half speed - takes double time to recharge)
                if (!autoFireDisabled && gameState.autoFireCharge < gameState.autoFireMaxCharge) {
                    gameState.autoFireCharge += deltaTime * 0.5; // Half speed recharge
                    if (gameState.autoFireCharge >= gameState.autoFireMaxCharge) {
                        gameState.autoFireCharge = gameState.autoFireMaxCharge;
                        gameState.autoFireAvailable = true;
                    }
                }
            }
            updateAutoFireUI();

            // Check superweapon keys
            checkSuperweaponKeys();

            // Check collision with aliens
            const px = centerX + Math.cos(gameState.player.angle) * gameState.player.orbitRadius;
            const py = centerY + Math.sin(gameState.player.angle) * gameState.player.orbitRadius;

            // Check quad ship and mirror ship collisions first
            checkQuadShipCollisions();
            checkMirrorShipCollisions();

            gameState.aliens = gameState.aliens.filter(alien => {
                const dx = px - alien.x;
                const dy = py - alien.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < gameState.player.size + alien.type.size) {
                    if (alien.type.isBonus) {
                        // Collect bonus ship
                        createAlienExplosion(alien.x, alien.y, alien.type);
                        playBonusExplosionSound();
                        gameState.score += alien.type.points;
                        dropPowerUp(alien.x, alien.y);
                        updateUI();
                        return false; // Remove bonus ship
                    } else {
                        // Regular alien - check if quad ships can absorb the hit
                        if (gameState.superweapons.quad.active) {
                            const aliveQuadShips = gameState.quadShips.filter(s => s.alive);
                            if (aliveQuadShips.length > 0) {
                                // Destroy the main ship position but continue with quad ships
                                createShipExplosion(px, py);
                                playShipExplosionSound();
                                // Mark that main ship is "destroyed" - move player to first alive quad ship
                                const firstAlive = aliveQuadShips[0];
                                gameState.player.angle += firstAlive.offset * Math.PI / 2;
                                firstAlive.alive = false;
                                return false; // Remove alien
                            }
                        }
                        // No quad ships left or quad not active - normal death
                        shipDestroyed(px, py);
                        return false; // Remove alien
                    }
                }

                return true;
            });
        }

        // Check quad ship collisions with aliens
        function checkQuadShipCollisions() {
            if (!gameState.superweapons.quad.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const orbitRadius = gameState.player.orbitRadius;

            gameState.quadShips.forEach(ship => {
                if (!ship.alive) return;

                const angle = gameState.player.angle + (ship.offset * Math.PI / 2);
                const shipX = centerX + Math.cos(angle) * orbitRadius;
                const shipY = centerY + Math.sin(angle) * orbitRadius;

                gameState.aliens = gameState.aliens.filter(alien => {
                    if (alien.type.isBonus) return true; // Don't check bonus ships

                    const dx = shipX - alien.x;
                    const dy = shipY - alien.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < gameState.player.size + alien.type.size) {
                        // Quad ship hit - destroy it
                        ship.alive = false;
                        createShipExplosion(shipX, shipY);
                        playShipExplosionSound();
                        return false; // Remove alien
                    }
                    return true;
                });
            });
        }

        // Check mirror ship collision with aliens
        function checkMirrorShipCollisions() {
            if (!gameState.mirrorShip || !gameState.mirrorShip.alive) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const orbitRadius = gameState.player.orbitRadius;

            const mirrorX = centerX + Math.cos(gameState.mirrorShip.angle) * orbitRadius;
            const mirrorY = centerY + Math.sin(gameState.mirrorShip.angle) * orbitRadius;

            gameState.aliens = gameState.aliens.filter(alien => {
                if (alien.type.isBonus) return true; // Don't check bonus ships

                const dx = mirrorX - alien.x;
                const dy = mirrorY - alien.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < gameState.player.size + alien.type.size) {
                    // Mirror ship hit - destroy it but game continues
                    gameState.mirrorShip.alive = false;
                    createShipExplosion(mirrorX, mirrorY);
                    playShipExplosionSound();
                    return false; // Remove alien
                }
                return true;
            });
        }

        // Create ship explosion particles (without triggering death)
        function createShipExplosion(x, y) {
            for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const speed = Math.random() * 3 + 1;
                gameState.explosionParticles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 45,
                    maxLife: 45,
                    size: Math.random() * 4 + 2,
                    color: Math.random() > 0.5 ? '#ff6600' : '#ffff00'
                });
            }
        }

        // Ship destroyed - create explosion and lose life
        function shipDestroyed(x, y) {
            gameState.exploding = true;
            gameState.explosionTimer = 90; // ~1.5s at 60fps

            // Create explosion particles
            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const speed = Math.random() * 3 + 1;
                gameState.explosionParticles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 60,
                    maxLife: 60,
                    size: Math.random() * 4 + 2,
                    color: Math.random() > 0.5 ? '#ff6600' : '#ffff00'
                });
            }

            playShipExplosionSound();

            // Lose a life after explosion
            setTimeout(() => {
                gameState.lives--;
                updateUI();

                if (gameState.lives <= 0) {
                    endGame('OUT OF LIVES');
                } else {
                    respawnPlayer();
                }
            }, 1500);
        }

        // Activate mirror ship
        function activateMirrorShip() {
            gameState.mirrorShip = {
                duration: customConfig.mirrorDuration * 60, // Configurable seconds
                angle: gameState.player.angle + Math.PI, // Opposite side
                alive: true
            };
        }

        // Update mirror ship
        function updateMirrorShip() {
            if (!gameState.mirrorShip) return;

            gameState.mirrorShip.duration -= deltaTime;
            if (gameState.mirrorShip.duration <= 0) {
                gameState.mirrorShip = null;
                return;
            }

            // Mirror ship follows player on opposite side (even if dead, keep tracking for timer)
            gameState.mirrorShip.angle = gameState.player.angle + Math.PI;
        }

        // Draw mirror ship (identical to player ship)
        function drawMirrorShip() {
            if (!gameState.mirrorShip || !gameState.mirrorShip.alive) return;

            const x = centerX + Math.cos(gameState.mirrorShip.angle) * gameState.player.orbitRadius;
            const y = centerY + Math.sin(gameState.mirrorShip.angle) * gameState.player.orbitRadius;

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(gameState.mirrorShip.angle + Math.PI / 2);

            // Use same size calculation as player
            let sizeMultiplier = 1.0;
            const speedUpgrades = Math.floor((gameState.player.speed - gameConfig.player.startingRotationSpeed) / gameConfig.player.rotationSpeedIncrement);
            sizeMultiplier += speedUpgrades * 0.02;
            if (gameState.player.bulletMode >= 3) sizeMultiplier += 0.15;
            if (gameState.player.bulletMode >= 5) sizeMultiplier += 0.15;

            const s = gameState.player.size * sizeMultiplier;

            // Use same colors as player based on power-ups
            let mainColor, highlightColor, accentColor;
            if (gameState.player.bulletMode === 5) {
                mainColor = '#ff0000';
                highlightColor = '#ff8800';
                accentColor = '#ffff00';
            } else if (gameState.player.bulletMode === 3) {
                mainColor = '#0088ff';
                highlightColor = '#00ffff';
                accentColor = '#88ffff';
            } else if (gameState.player.bulletMode === 2) {
                mainColor = '#8800ff';
                highlightColor = '#aa88ff';
                accentColor = '#ff00ff';
            } else {
                mainColor = '#00ff00';
                highlightColor = '#88ff88';
                accentColor = '#00ffaa';
            }

            // Nose
            ctx.fillStyle = mainColor;
            ctx.fillRect(-2, -s, 4, 4);
            ctx.fillStyle = highlightColor;
            ctx.fillRect(-1, -s, 2, 2);

            // Main body
            ctx.fillStyle = mainColor;
            ctx.fillRect(-4, -s + 4, 8, 8);
            ctx.fillStyle = highlightColor;
            ctx.fillRect(-3, -s + 5, 2, 2);
            ctx.fillRect(1, -s + 5, 2, 2);

            // Wings
            const wingSize = gameState.player.bulletMode >= 3 ? 1.2 : 1.0;
            ctx.fillStyle = mainColor;
            ctx.fillRect(-8 * wingSize, -s + 8, 4 * wingSize, 6);
            ctx.fillRect(4 * wingSize, -s + 8, 4 * wingSize, 6);
            ctx.fillStyle = accentColor;
            ctx.fillRect(-7 * wingSize, -s + 9, 2, 2);
            ctx.fillRect(5 * wingSize, -s + 9, 2, 2);

            // Additional weapon pods for x3 and x5
            if (gameState.player.bulletMode >= 3) {
                ctx.fillStyle = accentColor;
                ctx.fillRect(-10 * wingSize, -s + 6, 2, 4);
                ctx.fillRect(8 * wingSize, -s + 6, 2, 4);
            }
            if (gameState.player.bulletMode === 5) {
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-11 * wingSize, -s + 4, 2, 3);
                ctx.fillRect(9 * wingSize, -s + 4, 2, 3);
            }

            // Cockpit
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-2, -s + 6, 4, 3);
            ctx.fillStyle = '#0088ff';
            ctx.fillRect(-1, -s + 7, 2, 1);

            // Engine glow
            const engineColor = gameState.autoFireActive ? '#ff0000' : '#ffff00';
            const engineSize = gameState.autoFireActive ? 1.3 : 1.0;
            ctx.fillStyle = engineColor;
            ctx.fillRect(-3, s - 3 * engineSize, 2, 3 * engineSize);
            ctx.fillRect(1, s - 3 * engineSize, 2, 3 * engineSize);
            ctx.fillStyle = gameState.autoFireActive ? '#ffff00' : '#ffaa00';
            ctx.fillRect(-3, s - 2, 2, 2);
            ctx.fillRect(1, s - 2, 2, 2);

            // Speed trails
            if (speedUpgrades >= 5) {
                ctx.fillStyle = mainColor;
                ctx.globalAlpha = 0.4;
                ctx.fillRect(-2, s, 4, 4);
                ctx.fillRect(-1, s + 4, 2, 3);
                ctx.globalAlpha = 1.0;
            }

            ctx.restore();
        }

        // Mirror ship shoots when player shoots
        function mirrorShipShoot() {
            if (!gameState.mirrorShip || !gameState.mirrorShip.alive) return;

            const x = centerX + Math.cos(gameState.mirrorShip.angle) * gameState.player.orbitRadius;
            const y = centerY + Math.sin(gameState.mirrorShip.angle) * gameState.player.orbitRadius;
            const angle = gameState.mirrorShip.angle;
            const bulletSpeed = gameState.player.bulletSpeed;

            if (gameState.player.bulletMode === 1) {
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    size: 3
                });
            } else if (gameState.player.bulletMode === 2) {
                const spread = 0.15;
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle - spread) * bulletSpeed,
                    vy: Math.sin(angle - spread) * bulletSpeed,
                    size: 3
                });
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle + spread) * bulletSpeed,
                    vy: Math.sin(angle + spread) * bulletSpeed,
                    size: 3
                });
            } else if (gameState.player.bulletMode === 3) {
                const spread = 0.2;
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    size: 3
                });
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle - spread) * bulletSpeed,
                    vy: Math.sin(angle - spread) * bulletSpeed,
                    size: 3
                });
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle + spread) * bulletSpeed,
                    vy: Math.sin(angle + spread) * bulletSpeed,
                    size: 3
                });
            } else if (gameState.player.bulletMode === 4) {
                const spread = 0.18;
                for (let i = 0; i < 4; i++) {
                    const offset = (i - 1.5) * spread;
                    gameState.bullets.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle + offset) * bulletSpeed,
                        vy: Math.sin(angle + offset) * bulletSpeed,
                        size: 3
                    });
                }
            } else if (gameState.player.bulletMode === 5) {
                const spread = 0.15;
                for (let i = -2; i <= 2; i++) {
                    gameState.bullets.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle + i * spread) * bulletSpeed,
                        vy: Math.sin(angle + i * spread) * bulletSpeed,
                        size: 3
                    });
                }
            }
        }

        // Check if med ship should appear on this wave
        function shouldMedShipAppear(wave) {
            // Every other level until 10 (waves 3, 5, 7, 9), then every level from 10+
            if (wave < 3) return false;
            if (wave < 10) return wave % 2 === 1; // Odd waves: 3, 5, 7, 9
            return true; // Wave 10+: every wave
        }

        // Spawn Medical Ship
        function spawnMedShip() {
            if (!shouldMedShipAppear(gameState.wave) || gameState.medShip || gameState.medShipAppearedThisWave) return;

            gameState.medShipAppearedThisWave = true;
            gameState.medShipAppearances++;

            gameState.medShip = {
                x: -100, // Start off-screen left
                y: 150, // Upper part of screen
                vx: 1.8, // Faster glide speed
                vy: 0.3, // Gentle descent
                duration: 600, // Time on screen
                activated: false // Starts as alien ship, becomes med ship when hit
            };

            // Switch to med ship music (track 5)
            gameState.preMedShipMusicTrack = currentMusicTrack;
            currentMusicTrack = 5;
            startBackgroundMusic();
        }

        // Update Medical Ship
        function updateMedShip() {
            if (!gameState.medShip) {
                // Try to spawn med ship after 5 kills on eligible waves
                if (shouldMedShipAppear(gameState.wave) && !gameState.paused && !gameState.medShipAppearedThisWave) {
                    if (gameState.waveKills >= 5) {
                        spawnMedShip();
                    }
                }
                return;
            }

            if (gameState.paused) return;

            // Move med ship across screen (slow glide)
            gameState.medShip.x += gameState.medShip.vx * deltaTime;
            gameState.medShip.y += gameState.medShip.vy * deltaTime;

            // Gentle wave motion
            if (gameState.medShip.duration > 350) {
                gameState.medShip.vy = 0.2;
            } else {
                gameState.medShip.vy = -0.15;
            }

            // Med packs only drop when ship is hit - see checkMedShipCollisions()

            // Count down duration
            gameState.medShip.duration -= deltaTime;
            if (gameState.medShip.duration <= 0 || gameState.medShip.x > 1100) {
                // Med ship leaving - restore music
                currentMusicTrack = gameState.preMedShipMusicTrack || 0;
                startBackgroundMusic();
                gameState.medShip = null;
            }
        }

        // Drop med pack
        function dropMedPack() {
            if (!gameState.medShip) return;

            gameState.medPacks.push({
                x: gameState.medShip.x + 25,
                y: gameState.medShip.y + 15,
                vx: 0,
                vy: 2,
                rotation: 0,
                rotationSpeed: 0.05 // Slower rotation for med packs
            });
            playBonusExplosionSound();
        }

        // Check bullet collisions with med ship
        function checkMedShipCollisions() {
            if (!gameState.medShip || gameState.paused) return;

            const ship = gameState.medShip;
            // Ship hitbox: x to x+60, y to y+16
            const shipLeft = ship.x;
            const shipRight = ship.x + 60;
            const shipTop = ship.y - 8;
            const shipBottom = ship.y + 24;

            gameState.bullets = gameState.bullets.filter(bullet => {
                // Check if bullet hits ship
                if (bullet.x >= shipLeft && bullet.x <= shipRight &&
                    bullet.y >= shipTop && bullet.y <= shipBottom) {

                    if (!ship.activated) {
                        // First hit - transform from alien to med ship
                        ship.activated = true;
                        showLevelMessage('MED SHIP ACTIVATED!');
                        playBonusExplosionSound();
                    } else {
                        // Already activated - drop a med pack (no limit)
                        dropMedPack();
                    }
                    return false; // Remove bullet
                }
                return true; // Keep bullet
            });
        }

        // Update med packs
        function updateMedPacks() {
            if (gameState.paused) return;

            for (let i = gameState.medPacks.length - 1; i >= 0; i--) {
                const pack = gameState.medPacks[i];

                // Glide toward Earth center
                const dx = centerX - pack.x;
                const dy = centerY - pack.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const speed = 2.5;
                pack.x += (dx / dist) * speed * deltaTime;
                pack.y += (dy / dist) * speed * deltaTime;
                pack.rotation += pack.rotationSpeed * deltaTime;

                // Check if med pack reached Earth
                if (dist < 50) {
                    // Med packs boost Earth health by 1
                    gameState.earthHealth = Math.min(gameState.earthHealth + 1, gameConfig.player.maxEarthHealth);
                    gameState.medPacks.splice(i, 1);
                    playBonusExplosionSound();
                    showLevelMessage('EARTH +1 HP!');
                    flashStatusBar(2);
                    updateUI();
                } else if (pack.y > canvas.height + 50) {
                    gameState.medPacks.splice(i, 1);
                }
            }
        }

        // Draw Med Ship (alien ship before activation, medical ship after)
        function drawMedShip() {
            if (!gameState.medShip) return;

            const x = gameState.medShip.x;
            const y = gameState.medShip.y;
            const activated = gameState.medShip.activated;

            ctx.save();

            if (!activated) {
                // ALIEN SHIP (before first hit) - menacing red/orange
                const pulse = Math.sin(Date.now() / 80) * 0.2 + 0.8;

                // Main hull (dark red)
                ctx.fillStyle = '#660000';
                ctx.fillRect(x, y, 60, 16);

                // Armored plating
                ctx.fillStyle = '#880000';
                ctx.fillRect(x + 5, y + 2, 50, 12);

                // Cockpit (orange glow)
                ctx.fillStyle = `rgba(255, 100, 0, ${pulse})`;
                ctx.fillRect(x + 50, y + 4, 10, 8);

                // Engine glow (pulsing red/orange at back)
                ctx.fillStyle = `rgba(255, 80, 0, ${pulse})`;
                ctx.fillRect(x - 8, y + 3, 8, 10);

                // Engine exhaust
                ctx.fillStyle = `rgba(255, 50, 0, ${pulse * 0.5})`;
                ctx.fillRect(x - 14, y + 5, 6, 6);

                // Spiky fins (aggressive look)
                ctx.fillStyle = '#550000';
                ctx.beginPath();
                ctx.moveTo(x + 20, y);
                ctx.lineTo(x + 30, y - 12);
                ctx.lineTo(x + 35, y);
                ctx.closePath();
                ctx.fill();

                ctx.beginPath();
                ctx.moveTo(x + 20, y + 16);
                ctx.lineTo(x + 30, y + 28);
                ctx.lineTo(x + 35, y + 16);
                ctx.closePath();
                ctx.fill();

                // Weapon ports
                ctx.fillStyle = '#ff4400';
                ctx.fillRect(x + 55, y + 2, 4, 3);
                ctx.fillRect(x + 55, y + 11, 4, 3);

            } else {
                // MEDICAL SHIP (after activation) - white/silver friendly

                // Main hull (silver/white elongated shape)
                ctx.fillStyle = '#e0e0e0';
                ctx.fillRect(x, y, 60, 16);

                // Cockpit (darker front section)
                ctx.fillStyle = '#a0a0a0';
                ctx.fillRect(x + 50, y + 2, 12, 12);

                // Cockpit window (cyan glow)
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(x + 54, y + 4, 6, 8);

                // Red cross on hull (medical symbol)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(x + 20, y + 2, 4, 12); // Vertical
                ctx.fillRect(x + 14, y + 6, 16, 4); // Horizontal

                // Engine glow (pulsing cyan at back)
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
                ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
                ctx.fillRect(x - 8, y + 3, 8, 10);

                // Engine exhaust particles
                ctx.fillStyle = `rgba(0, 200, 255, ${pulse * 0.5})`;
                ctx.fillRect(x - 14, y + 5, 6, 6);
                ctx.fillRect(x - 18, y + 6, 4, 4);

                // Top fin
                ctx.fillStyle = '#c0c0c0';
                ctx.beginPath();
                ctx.moveTo(x + 25, y);
                ctx.lineTo(x + 35, y - 8);
                ctx.lineTo(x + 40, y);
                ctx.closePath();
                ctx.fill();

                // Bottom fin
                ctx.beginPath();
                ctx.moveTo(x + 25, y + 16);
                ctx.lineTo(x + 35, y + 24);
                ctx.lineTo(x + 40, y + 16);
                ctx.closePath();
                ctx.fill();

                // Hull detail lines
                ctx.fillStyle = '#888888';
                ctx.fillRect(x + 5, y + 7, 10, 2);
                ctx.fillRect(x + 42, y + 7, 8, 2);
            }

            ctx.restore();
        }

        // Draw med packs (white case with red cross)
        function drawMedPacks() {
            gameState.medPacks.forEach(pack => {
                ctx.save();
                ctx.translate(pack.x, pack.y);
                ctx.rotate(pack.rotation);

                // White case
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-7, -7, 14, 14);

                // Case border
                ctx.fillStyle = '#cccccc';
                ctx.fillRect(-8, -8, 16, 2);
                ctx.fillRect(-8, 6, 16, 2);
                ctx.fillRect(-8, -8, 2, 16);
                ctx.fillRect(6, -8, 2, 16);

                // Red cross
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-1, -5, 2, 10); // Vertical
                ctx.fillRect(-5, -1, 10, 2); // Horizontal

                ctx.restore();
            });
        }

        // Fixed keys for superweapons: Shield=1, Hyperkill=2, Satellites=3, Quad=4, Rockets=5
        const SUPERWEAPON_KEYS = {
            shield: '1',
            hyperkill: '2',
            satellites: '3',
            quad: '4',
            rockets: '5'
        };

        // Get fixed key for superweapon
        function getSuperweaponKey(weaponId) {
            return SUPERWEAPON_KEYS[weaponId] || null;
        }

        // Update superweapon UI item
        function updateSuperweaponButton(weaponId) {
            const sw = gameState.superweapons[weaponId];
            const item = document.querySelector(`.superweapon-item[data-weapon="${weaponId}"]`);
            if (!item) return;

            const keyHint = item.querySelector('.key-hint');
            // Always show the fixed key number
            keyHint.textContent = SUPERWEAPON_KEYS[weaponId];

            // Update count display
            let countEl = item.querySelector('.superweapon-count');
            if (!countEl) {
                countEl = document.createElement('span');
                countEl.className = 'superweapon-count';
                item.appendChild(countEl);
            }
            countEl.textContent = sw.count > 0 ? `x${sw.count}` : '';

            if (sw.count > 0) {
                item.classList.add('available');
            } else {
                item.classList.remove('available');
            }

            if (sw.active) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }

            // Grey out if another superweapon is active (except hyperkill which is instant)
            if (gameState.activeSuperweapon && !sw.active && weaponId !== 'hyperkill') {
                item.classList.add('locked');
            } else {
                item.classList.remove('locked');
            }
        }

        // Update all superweapon buttons
        function updateAllSuperweaponButtons() {
            Object.keys(gameState.superweapons).forEach(updateSuperweaponButton);
        }

        // Give player a superweapon pickup
        function giveSuperweapon(weaponId) {
            const sw = gameState.superweapons[weaponId];

            sw.count++;
            sw.key = getSuperweaponKey(weaponId);
            gameState.superweaponPickupsThisLevel++;
            updateSuperweaponButton(weaponId);

            const names = {
                shield: 'SHIELD',
                hyperkill: 'HYPERKILL',
                satellites: 'SATELLITES',
                quad: 'QUAD',
                rockets: 'ROCKETS'
            };
            showLevelMessage(`${names[weaponId]}! Press ${sw.key.toUpperCase()}`);
            return true;
        }

        // Trigger superweapon by ID or key
        function triggerSuperweapon(weaponId) {
            const sw = gameState.superweapons[weaponId];
            if (!sw || sw.count <= 0) return;

            // Can't activate if another timed superweapon is active
            if (gameState.activeSuperweapon && weaponId !== 'hyperkill') return;

            sw.count--;
            updateSuperweaponButton(weaponId);

            switch (weaponId) {
                case 'hyperkill':
                    activateHyperKill();
                    break;
                case 'shield':
                    activateShield();
                    break;
                case 'satellites':
                    activateSatellites();
                    break;
                case 'quad':
                    activateQuad();
                    break;
                case 'rockets':
                    activateRockets();
                    break;
            }
        }

        // Check keyboard for superweapon triggers
        function checkSuperweaponKeys() {
            // Don't allow triggers during cooldown (prevents accidental use on pickup)
            if (gameState.superweaponCooldown > 0) {
                gameState.superweaponCooldown -= deltaTime;
                return;
            }

            Object.entries(gameState.superweapons).forEach(([weaponId, sw]) => {
                if (sw.count > 0 && sw.key && gameState.keys[sw.key]) {
                    triggerSuperweapon(weaponId);
                    gameState.keys[sw.key] = false; // Prevent repeat
                }
            });
        }

        // Update superweapon timer display
        function updateSuperweaponTimerDisplay() {
            const timerEl = document.getElementById('superweaponTimer');
            if (gameState.activeSuperweapon && gameState.superweaponTimer > 0) {
                const seconds = Math.ceil(gameState.superweaponTimer / 60);
                timerEl.textContent = `${gameState.activeSuperweapon.toUpperCase()}: ${seconds}s`;
                timerEl.classList.add('active');
            } else {
                timerEl.classList.remove('active');
            }
        }

        // Activate HyperKill (instant screen clear)
        function activateHyperKill() {
            playScreenClearSound();

            // Create massive explosions for all aliens
            gameState.aliens.forEach(alien => {
                createAlienExplosion(alien.x, alien.y, alien.type);
                gameState.score += Math.floor(alien.type.points / 2);
                if (!alien.type.isBonus) {
                    gameState.waveKills++;
                    checkSuperweaponSpawn();
                    checkLifeBonusSpawn();
                }
            });

            gameState.aliens = [];
            updateUI();

            if (gameState.waveKills >= gameState.waveTarget) {
                nextWave();
            }
        }

        // Activate Shield (pulsing ring around Earth)
        function activateShield() {
            gameState.activeSuperweapon = 'shield';
            gameState.superweaponTimer = customConfig.superweaponDuration * 60;
            gameState.superweapons.shield.active = true;
            updateAllSuperweaponButtons();
            playPowerUpSound();
        }

        // Activate Satellites (4 rotating satellites)
        function activateSatellites() {
            gameState.activeSuperweapon = 'satellites';
            gameState.superweaponTimer = customConfig.superweaponDuration * 60;
            gameState.superweapons.satellites.active = true;
            // Initialize 4 satellites at corners of square
            gameState.satellites = [
                { angle: 0 },
                { angle: Math.PI / 2 },
                { angle: Math.PI },
                { angle: Math.PI * 1.5 }
            ];
            updateAllSuperweaponButtons();
            playPowerUpSound();
        }

        // Activate Quad (4 ships around Earth)
        function activateQuad() {
            gameState.activeSuperweapon = 'quad';
            gameState.superweaponTimer = customConfig.superweaponDuration * 60;
            gameState.superweapons.quad.active = true;
            // Initialize 3 extra ships at 90-degree intervals, all alive
            gameState.quadShips = [
                { offset: 1, alive: true }, // 90 degrees from player
                { offset: 2, alive: true }, // 180 degrees from player
                { offset: 3, alive: true }  // 270 degrees from player
            ];
            updateAllSuperweaponButtons();
            playPowerUpSound();
        }

        // Activate Rockets (bullets become homing)
        function activateRockets() {
            gameState.activeSuperweapon = 'rockets';
            gameState.superweaponTimer = customConfig.superweaponDuration * 60;
            gameState.superweapons.rockets.active = true;
            gameState.missiles = [];
            gameState.missileFireTimer = 0;
            updateAllSuperweaponButtons();
            playPowerUpSound();
        }

        // Update active superweapon
        let lastSuperweaponSecond = -1; // Track for sound effects
        function updateActiveSuperweapon() {
            if (!gameState.activeSuperweapon) return;

            const prevSeconds = Math.ceil(gameState.superweaponTimer / 60);
            gameState.superweaponTimer -= deltaTime;
            const currSeconds = Math.ceil(gameState.superweaponTimer / 60);
            updateSuperweaponTimerDisplay();

            // Play tick sound when second changes
            if (currSeconds !== prevSeconds && currSeconds > 0 && currSeconds <= 5) {
                playSuperweaponTickSound(currSeconds);
            }

            if (gameState.superweaponTimer <= 0) {
                deactivateSuperweapon();
            }
        }

        // Deactivate current superweapon
        function deactivateSuperweapon() {
            if (!gameState.activeSuperweapon) return;

            const weaponId = gameState.activeSuperweapon;
            gameState.superweapons[weaponId].active = false;

            gameState.activeSuperweapon = null;
            gameState.superweaponTimer = 0;
            gameState.satellites = [];
            gameState.quadShips = [];
            gameState.missiles = [];
            updateAllSuperweaponButtons();
            updateSuperweaponTimerDisplay();
            playSuperweaponExpiredSound();
        }

        // Draw shield effect
        function drawShield() {
            if (!gameState.superweapons.shield.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const shieldRadius = customConfig.shieldRadius;

            // Pulsing effect
            const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            const innerPulse = Math.sin(Date.now() / 150) * 10;

            ctx.save();

            // Outer glow
            ctx.strokeStyle = `rgba(0, 255, 255, ${pulse * 0.5})`;
            ctx.lineWidth = 8 + innerPulse;
            ctx.beginPath();
            ctx.arc(centerX, centerY, shieldRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner ring
            ctx.strokeStyle = `rgba(0, 255, 255, ${pulse})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, shieldRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Cloud particles
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 2 + Date.now() / 1000;
                const wobble = Math.sin(Date.now() / 200 + i) * 5;
                const x = centerX + Math.cos(angle) * (shieldRadius + wobble);
                const y = centerY + Math.sin(angle) * (shieldRadius + wobble);
                const size = 3 + Math.sin(Date.now() / 100 + i) * 2;

                ctx.fillStyle = `rgba(0, 255, 255, ${pulse * 0.8})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Draw satellites
        function drawSatellites() {
            if (!gameState.superweapons.satellites.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const satRadius = customConfig.satelliteRadius;

            gameState.satellites.forEach((sat, i) => {
                const x = centerX + Math.cos(sat.angle) * satRadius;
                const y = centerY + Math.sin(sat.angle) * satRadius;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(sat.spin || 0); // Spin on own axis when player moves

                // Satellite body
                ctx.fillStyle = '#888888';
                ctx.fillRect(-6, -6, 12, 12);

                // Solar panels
                ctx.fillStyle = '#666666';
                ctx.fillRect(-14, -3, 6, 6);
                ctx.fillRect(8, -3, 6, 6);

                // Glow
                ctx.strokeStyle = 'rgba(150, 150, 150, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(-7, -7, 14, 14);

                ctx.restore();
            });
        }

        // Draw quad ships
        function drawQuadShips() {
            if (!gameState.superweapons.quad.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const orbitRadius = gameState.player.orbitRadius;

            // Calculate size scaling (same as main ship)
            let sizeMultiplier = 1.0;
            const speedUpgrades = Math.floor((gameState.player.speed - gameConfig.player.startingRotationSpeed) / gameConfig.player.rotationSpeedIncrement);
            sizeMultiplier += speedUpgrades * 0.02;
            if (gameState.player.bulletMode >= 3) sizeMultiplier += 0.15;
            if (gameState.player.bulletMode >= 5) sizeMultiplier += 0.15;
            const s = gameState.player.size * sizeMultiplier;

            // Determine colors (same as main ship)
            let mainColor, highlightColor, accentColor;
            if (gameState.player.bulletMode === 5) {
                mainColor = '#ff0000';
                highlightColor = '#ff8800';
                accentColor = '#ffff00';
            } else if (gameState.player.bulletMode === 3) {
                mainColor = '#0088ff';
                highlightColor = '#00ffff';
                accentColor = '#88ffff';
            } else if (gameState.player.bulletMode === 2) {
                mainColor = '#8800ff';
                highlightColor = '#aa88ff';
                accentColor = '#ff00ff';
            } else {
                mainColor = '#00ff00';
                highlightColor = '#88ff88';
                accentColor = '#00ffaa';
            }

            const wingSize = gameState.player.bulletMode >= 3 ? 1.2 : 1.0;

            // Draw only alive quad ships
            gameState.quadShips.forEach(ship => {
                if (!ship.alive) return;

                const angle = gameState.player.angle + (ship.offset * Math.PI / 2);
                const x = centerX + Math.cos(angle) * orbitRadius;
                const y = centerY + Math.sin(angle) * orbitRadius;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + Math.PI / 2);
                ctx.globalAlpha = 0.85;

                // Nose
                ctx.fillStyle = mainColor;
                ctx.fillRect(-2, -s, 4, 4);
                ctx.fillStyle = highlightColor;
                ctx.fillRect(-1, -s, 2, 2);

                // Main body
                ctx.fillStyle = mainColor;
                ctx.fillRect(-4, -s + 4, 8, 8);
                ctx.fillStyle = highlightColor;
                ctx.fillRect(-3, -s + 5, 2, 2);
                ctx.fillRect(1, -s + 5, 2, 2);

                // Wings
                ctx.fillStyle = mainColor;
                ctx.fillRect(-8 * wingSize, -s + 8, 4 * wingSize, 6);
                ctx.fillRect(4 * wingSize, -s + 8, 4 * wingSize, 6);
                ctx.fillStyle = accentColor;
                ctx.fillRect(-7 * wingSize, -s + 9, 2, 2);
                ctx.fillRect(5 * wingSize, -s + 9, 2, 2);

                // Weapon pods
                if (gameState.player.bulletMode >= 3) {
                    ctx.fillStyle = accentColor;
                    ctx.fillRect(-10 * wingSize, -s + 6, 2, 4);
                    ctx.fillRect(8 * wingSize, -s + 6, 2, 4);
                }
                if (gameState.player.bulletMode === 5) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(-11 * wingSize, -s + 4, 2, 3);
                    ctx.fillRect(9 * wingSize, -s + 4, 2, 3);
                }

                // Cockpit
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-2, -s + 6, 4, 3);
                ctx.fillStyle = '#0088ff';
                ctx.fillRect(-1, -s + 7, 2, 1);

                // Engines
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-3, s - 3, 2, 3);
                ctx.fillRect(1, s - 3, 2, 3);
                ctx.fillStyle = '#ffaa00';
                ctx.fillRect(-3, s - 2, 2, 2);
                ctx.fillRect(1, s - 2, 2, 2);

                ctx.restore();
            });
        }

        // Update satellites (fixed in space, spin when player moves)
        function updateSatellites() {
            if (!gameState.superweapons.satellites.active) return;

            // Satellites spin on their axis only when player is moving
            gameState.satellites.forEach(sat => {
                if (gameState.keys['q']) {
                    sat.spin = (sat.spin || 0) - 0.15 * deltaTime;
                }
                if (gameState.keys['a']) {
                    sat.spin = (sat.spin || 0) + 0.15 * deltaTime;
                }
            });
        }

        // Shoot from satellites
        function shootFromSatellites() {
            if (!gameState.superweapons.satellites.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const satRadius = customConfig.satelliteRadius;

            gameState.satellites.forEach(sat => {
                const x = centerX + Math.cos(sat.angle) * satRadius;
                const y = centerY + Math.sin(sat.angle) * satRadius;

                // Shoot in direction satellite is facing (base angle + spin rotation)
                const bulletAngle = sat.angle + (sat.spin || 0);
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(bulletAngle) * gameState.player.bulletSpeed,
                    vy: Math.sin(bulletAngle) * gameState.player.bulletSpeed,
                    size: 3,
                    isRocket: gameState.superweapons.rockets.active
                });
            });
        }

        // Shoot from quad ships (same firepower as main ship)
        function shootFromQuadShips() {
            if (!gameState.superweapons.quad.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const orbitRadius = gameState.player.orbitRadius;
            const bulletSpeed = gameState.player.bulletSpeed;
            const bulletMode = gameState.player.bulletMode;
            const isRocket = gameState.superweapons.rockets.active;

            gameState.quadShips.forEach(ship => {
                if (!ship.alive) return;

                const angle = gameState.player.angle + (ship.offset * Math.PI / 2);
                const x = centerX + Math.cos(angle) * orbitRadius;
                const y = centerY + Math.sin(angle) * orbitRadius;

                // Shoot with same firepower as main ship
                if (bulletMode === 1) {
                    gameState.bullets.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * bulletSpeed,
                        vy: Math.sin(angle) * bulletSpeed,
                        size: 3, isRocket: isRocket
                    });
                } else if (bulletMode === 2) {
                    const spread = 0.15;
                    gameState.bullets.push({
                        x: x, y: y,
                        vx: Math.cos(angle - spread) * bulletSpeed,
                        vy: Math.sin(angle - spread) * bulletSpeed,
                        size: 3, isRocket: isRocket
                    });
                    gameState.bullets.push({
                        x: x, y: y,
                        vx: Math.cos(angle + spread) * bulletSpeed,
                        vy: Math.sin(angle + spread) * bulletSpeed,
                        size: 3, isRocket: isRocket
                    });
                } else if (bulletMode === 3) {
                    const spread = 0.2;
                    gameState.bullets.push({
                        x: x, y: y,
                        vx: Math.cos(angle) * bulletSpeed,
                        vy: Math.sin(angle) * bulletSpeed,
                        size: 3, isRocket: isRocket
                    });
                    gameState.bullets.push({
                        x: x, y: y,
                        vx: Math.cos(angle - spread) * bulletSpeed,
                        vy: Math.sin(angle - spread) * bulletSpeed,
                        size: 3, isRocket: isRocket
                    });
                    gameState.bullets.push({
                        x: x, y: y,
                        vx: Math.cos(angle + spread) * bulletSpeed,
                        vy: Math.sin(angle + spread) * bulletSpeed,
                        size: 3, isRocket: isRocket
                    });
                } else if (bulletMode === 4) {
                    const spread = 0.15;
                    for (let i = -1.5; i <= 1.5; i++) {
                        gameState.bullets.push({
                            x: x, y: y,
                            vx: Math.cos(angle + spread * i) * bulletSpeed,
                            vy: Math.sin(angle + spread * i) * bulletSpeed,
                            size: 3, isRocket: isRocket
                        });
                    }
                } else if (bulletMode >= 5) {
                    const spread = 0.12;
                    for (let i = -2; i <= 2; i++) {
                        gameState.bullets.push({
                            x: x, y: y,
                            vx: Math.cos(angle + spread * i) * bulletSpeed,
                            vy: Math.sin(angle + spread * i) * bulletSpeed,
                            size: 3, isRocket: isRocket
                        });
                    }
                }
            });
        }

        // Check shield collision with aliens
        function checkShieldCollisions() {
            if (!gameState.superweapons.shield.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const shieldRadius = customConfig.shieldRadius;

            gameState.aliens = gameState.aliens.filter(alien => {
                const dx = alien.x - centerX;
                const dy = alien.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= shieldRadius + alien.type.size) {
                    // Alien hit shield - destroy it
                    createAlienExplosion(alien.x, alien.y, alien.type);
                    gameState.score += alien.type.points;
                    if (!alien.type.isBonus) {
                        gameState.waveKills++;
                        checkSuperweaponSpawn();
                        checkLifeBonusSpawn();
                    }
                    playShieldZapSound();
                    return false;
                }
                return true;
            });

            // Shield also collects power-ups
            gameState.powerUps = gameState.powerUps.filter(powerUp => {
                const dx = powerUp.x - centerX;
                const dy = powerUp.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist <= shieldRadius + 10) {
                    // Power-up collected by shield
                    applyPowerUp(powerUp.type);
                    playPowerUpSound();
                    return false;
                }
                return true;
            });
        }

        // Check satellite collisions with aliens
        function checkSatelliteCollisions() {
            if (!gameState.superweapons.satellites.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const satRadius = customConfig.satelliteRadius;

            gameState.satellites.forEach(sat => {
                const satX = centerX + Math.cos(sat.angle) * satRadius;
                const satY = centerY + Math.sin(sat.angle) * satRadius;

                gameState.aliens = gameState.aliens.filter(alien => {
                    const dx = alien.x - satX;
                    const dy = alien.y - satY;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < alien.type.size + 8) {
                        createAlienExplosion(alien.x, alien.y, alien.type);
                        gameState.score += alien.type.points;
                        if (!alien.type.isBonus) {
                            gameState.waveKills++;
                            checkSuperweaponSpawn();
                            checkLifeBonusSpawn();
                        }
                        playAlienDeathSound();
                        return false;
                    }
                    return true;
                });
            });
        }

        // Update missile barrage system
        function updateMissiles() {
            if (!gameState.superweapons.rockets.active) return;

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Auto-fire missiles (scales with wave level)
            // Fire rate: 40 frames at wave 1, down to 15 frames at wave 20
            const fireRate = Math.max(15, 40 - (gameState.wave - 1) * 1.5);
            // Max missiles: 5 at wave 1, up to 12 at wave 20
            const maxMissiles = Math.min(12, 5 + Math.floor(gameState.wave / 3));

            gameState.missileFireTimer += deltaTime;
            if (gameState.missileFireTimer >= fireRate && gameState.missiles.length < maxMissiles) {
                gameState.missileFireTimer = 0;

                // Fire from player position
                const px = centerX + Math.cos(gameState.player.angle) * gameState.player.orbitRadius;
                const py = centerY + Math.sin(gameState.player.angle) * gameState.player.orbitRadius;

                // Find a target alien
                let targetAlien = null;
                let closestDist = Infinity;
                gameState.aliens.forEach(alien => {
                    const dx = alien.x - px;
                    const dy = alien.y - py;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < closestDist) {
                        closestDist = dist;
                        targetAlien = alien;
                    }
                });

                // Fire toward target or outward if no target
                let angle = gameState.player.angle;
                if (targetAlien) {
                    angle = Math.atan2(targetAlien.y - py, targetAlien.x - px);
                }

                const speed = 6;
                gameState.missiles.push({
                    x: px,
                    y: py,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    trail: [], // For smoke trail
                    target: targetAlien
                });

                playMissileSound();
            }

            // Update missile positions first
            gameState.missiles.forEach(missile => {
                // Simple trail
                missile.trail.unshift({ x: missile.x, y: missile.y });
                if (missile.trail.length > 5) missile.trail.pop();

                // Homing behavior
                if (missile.target && gameState.aliens.includes(missile.target)) {
                    const dx = missile.target.x - missile.x;
                    const dy = missile.target.y - missile.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        missile.vx += (dx / dist) * 0.3 * deltaTime;
                        missile.vy += (dy / dist) * 0.3 * deltaTime;
                        const speed = Math.sqrt(missile.vx * missile.vx + missile.vy * missile.vy);
                        if (speed > 8) {
                            missile.vx = (missile.vx / speed) * 8;
                            missile.vy = (missile.vy / speed) * 8;
                        }
                    }
                }

                missile.x += missile.vx * deltaTime;
                missile.y += missile.vy * deltaTime;
            });

            // Collect missile hits first, then process
            const missileHits = [];

            gameState.missiles = gameState.missiles.filter(missile => {
                // Check if off screen
                if (missile.x < -50 || missile.x > canvas.width + 50 ||
                    missile.y < -50 || missile.y > canvas.height + 50) {
                    return false;
                }

                // Check collision with any alien
                for (let i = 0; i < gameState.aliens.length; i++) {
                    const alien = gameState.aliens[i];
                    const dx = alien.x - missile.x;
                    const dy = alien.y - missile.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 15 + alien.type.size) {
                        missileHits.push({ alien: alien, x: missile.x, y: missile.y });
                        return false; // Remove missile
                    }
                }
                return true; // Keep missile
            });

            // Process hits after missile filter is complete
            missileHits.forEach(hit => {
                hit.alien.health -= customConfig.missileDamage;
            });

            // Remove dead aliens (separate pass to avoid nested modification)
            const deadAliens = gameState.aliens.filter(alien => alien.health <= 0);
            if (deadAliens.length > 0) {
                deadAliens.forEach(alien => {
                    createAlienExplosion(alien.x, alien.y, alien.type);
                    if (alien.type.isBonus) {
                        playBonusExplosionSound();
                    } else {
                        playSmallExplosionSound();
                    }
                    gameState.score += alien.type.points;
                    if (!alien.type.isBonus) {
                        gameState.waveKills++;
                    }
                });

                gameState.aliens = gameState.aliens.filter(alien => alien.health > 0);
                updateUI();

                if (gameState.waveKills >= gameState.waveTarget) {
                    nextWave();
                }
            }
        }

        // Create missile explosion effect (small, simple)
        function createMissileExplosion(x, y) {
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6;
                const speed = Math.random() * 2 + 1;
                gameState.explosionParticles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 15,
                    maxLife: 15,
                    size: 3,
                    color: '#ff4400'
                });
            }
        }

        // Play missile launch sound
        function playMissileSound() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);

            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

            osc.start(now);
            osc.stop(now + 0.1);
        }

        // Draw missiles with smoke trails
        function drawMissiles() {
            gameState.missiles.forEach(missile => {
                // Draw simple smoke trail
                missile.trail.forEach((t, i) => {
                    const alpha = 1 - (i / missile.trail.length);
                    ctx.fillStyle = `rgba(80, 80, 80, ${alpha * 0.4})`;
                    ctx.fillRect(t.x - 2, t.y - 2, 4, 4);
                });

                // Draw simple missile
                ctx.fillStyle = '#ff4400';
                ctx.fillRect(missile.x - 4, missile.y - 2, 8, 4);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(missile.x - 6, missile.y - 1, 3, 2);
            });
        }

        // Reset all superweapons
        function resetSuperweapons() {
            Object.keys(gameState.superweapons).forEach(weaponId => {
                gameState.superweapons[weaponId].count = 0;
                gameState.superweapons[weaponId].key = getSuperweaponKey(weaponId);
                gameState.superweapons[weaponId].active = false;
                gameState.superweapons[weaponId].timer = 0;
            });
            gameState.activeSuperweapon = null;
            gameState.superweaponTimer = 0;
            gameState.satellites = [];
            gameState.quadShips = [];
            gameState.missiles = [];
            gameState.superweaponPickupsThisLevel = 0;
            updateAllSuperweaponButtons();
            updateSuperweaponTimerDisplay();
        }

        // Respawn player (continue from current position)
        function respawnPlayer() {
            // Reset player position
            gameState.player.angle = 0;

            // Hybrid death penalty (lose fixed amount OR 25%, whichever is MORE)

            // Speed: Lose 2 upgrades OR 25% (whichever is MORE)
            const startingSpeed = gameConfig.player.startingRotationSpeed;
            const speedIncrement = gameConfig.player.rotationSpeedIncrement;
            const speedUpgrades = (gameState.player.speed - startingSpeed) / speedIncrement;
            const fixedSpeedLoss = 2;
            const percentSpeedLoss = Math.floor(speedUpgrades * 0.25);
            const speedLoss = Math.max(fixedSpeedLoss, percentSpeedLoss);
            const remainingSpeed = Math.max(0, speedUpgrades - speedLoss);
            gameState.player.speed = startingSpeed + (remainingSpeed * speedIncrement);
            gameState.player.baseSpeed = gameState.player.speed;

            // Fire rate: Lose 1 upgrade OR 25% (whichever is MORE)
            const startingFireRate = gameConfig.player.startingFireRate;
            const fireRateIncrement = Math.abs(gameConfig.player.fireRateIncrement);
            const fireRateUpgrades = (startingFireRate - gameState.player.shootCooldownTime) / fireRateIncrement;
            const fixedFireRateLoss = 1;
            const percentFireRateLoss = Math.floor(fireRateUpgrades * 0.25);
            const fireRateLoss = Math.max(fixedFireRateLoss, percentFireRateLoss);
            const remainingFireRate = Math.max(0, fireRateUpgrades - fireRateLoss);
            gameState.player.shootCooldownTime = startingFireRate - (remainingFireRate * fireRateIncrement);

            // Bullet speed: Lose 1 upgrade OR 25% (whichever is MORE)
            const startingBulletSpeed = gameConfig.player.startingBulletSpeed;
            const bulletSpeedIncrement = gameConfig.player.bulletSpeedIncrement;
            const bulletSpeedUpgrades = (gameState.player.bulletSpeed - startingBulletSpeed) / bulletSpeedIncrement;
            const fixedBulletSpeedLoss = 1;
            const percentBulletSpeedLoss = Math.floor(bulletSpeedUpgrades * 0.25);
            const bulletSpeedLoss = Math.max(fixedBulletSpeedLoss, percentBulletSpeedLoss);
            const remainingBulletSpeed = Math.max(0, bulletSpeedUpgrades - bulletSpeedLoss);
            gameState.player.bulletSpeed = startingBulletSpeed + (remainingBulletSpeed * bulletSpeedIncrement);

            // Firepower (bulletMode) is never lost on death

            gameState.player.shootCooldown = 0;

            // Reset auto-fire to full charge on respawn
            gameState.autoFireCharge = gameState.autoFireMaxCharge;
            gameState.autoFireAvailable = true;
            gameState.autoFireActive = false;

            // Clear temporary power-ups
            gameState.mirrorShip = null;
            deactivateSuperweapon(); // Deactivate any active superweapon

            // Clear player's bullets and explosion particles
            gameState.bullets = [];
            gameState.explosionParticles = [];

            // Move all aliens back to the edge and reset movement properties
            gameState.aliens.forEach(alien => {
                const angle = Math.random() * Math.PI * 2;
                const distance = canvas.width * 0.5;
                alien.x = centerX + Math.cos(angle) * distance;
                alien.y = centerY + Math.sin(angle) * distance;
                alien.timeAlive = 0;
                alien.orbitDistance = distance;
                alien.wobbleOffset = Math.random() * Math.PI * 2;
                alien.targetAngle = null;
            });

            gameState.exploding = false;
            gameState.paused = false;
        }

        // Reset wave after death (only used for full wave restart if needed)
        function resetWave() {
            // Clear all entities
            gameState.bullets = [];
            gameState.aliens = [];
            gameState.powerUps = [];
            gameState.explosionParticles = [];

            // Reset player to defaults from config
            gameState.player.angle = 0;
            gameState.player.speed = gameConfig.player.startingRotationSpeed;
            gameState.player.baseSpeed = gameConfig.player.startingRotationSpeed;
            gameState.player.bulletMode = gameConfig.player.startingBulletMode;
            gameState.player.bulletSpeed = gameConfig.player.startingBulletSpeed;
            gameState.player.shootCooldown = 0;
            gameState.player.shootCooldownTime = gameConfig.player.startingFireRate;

            // Reset superweapons
            resetSuperweapons();

            // Reset wave progress
            gameState.alienSpawnTimer = 0;
            gameState.bonusSpawnTimer = 0;
            gameState.waveKills = 0;

            gameState.exploding = false;
            gameState.paused = false;
        }

        // Shoot bullet
        function shoot() {
            // Check cooldown
            if (gameState.player.shootCooldown > 0) return;

            const x = centerX + Math.cos(gameState.player.angle) * gameState.player.orbitRadius;
            const y = centerY + Math.sin(gameState.player.angle) * gameState.player.orbitRadius;
            const angle = gameState.player.angle;
            const bulletSpeed = gameState.player.bulletSpeed;

            // Check if rockets superweapon is active
            const isRocket = gameState.superweapons.rockets.active;

            if (gameState.player.bulletMode === 1) {
                // Single bullet
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    size: 3,
                    isRocket: isRocket
                });
            } else if (gameState.player.bulletMode === 2) {
                // Double bullets
                const spread = 0.15;
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle - spread) * bulletSpeed,
                    vy: Math.sin(angle - spread) * bulletSpeed,
                    size: 3,
                    isRocket: isRocket
                });
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle + spread) * bulletSpeed,
                    vy: Math.sin(angle + spread) * bulletSpeed,
                    size: 3,
                    isRocket: isRocket
                });
            } else if (gameState.player.bulletMode === 3) {
                // Triple bullets
                const spread = 0.2;
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    size: 3,
                    isRocket: isRocket
                });
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle - spread) * bulletSpeed,
                    vy: Math.sin(angle - spread) * bulletSpeed,
                    size: 3,
                    isRocket: isRocket
                });
                gameState.bullets.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle + spread) * bulletSpeed,
                    vy: Math.sin(angle + spread) * bulletSpeed,
                    size: 3,
                    isRocket: isRocket
                });
            } else if (gameState.player.bulletMode === 4) {
                // Quad bullets
                const spread = 0.18;
                for (let i = 0; i < 4; i++) {
                    const offset = (i - 1.5) * spread;
                    gameState.bullets.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle + offset) * bulletSpeed,
                        vy: Math.sin(angle + offset) * bulletSpeed,
                        size: 3,
                        isRocket: isRocket
                    });
                }
            } else if (gameState.player.bulletMode === 5) {
                // Quintuple bullets
                const spread = 0.15;
                for (let i = -2; i <= 2; i++) {
                    gameState.bullets.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle + i * spread) * bulletSpeed,
                        vy: Math.sin(angle + i * spread) * bulletSpeed,
                        size: 3,
                        isRocket: isRocket
                    });
                }
            }

            // Reset cooldown (skip if auto-fire)
            if (gameState.player.shootCooldownTime > 0) {
                gameState.player.shootCooldown = gameState.player.shootCooldownTime;
            } else {
                gameState.player.shootCooldown = 2; // Minimum 2 frames even in auto-fire
            }

            // Mirror ship also shoots
            if (gameState.mirrorShip) {
                mirrorShipShoot();
            }

            // Satellites shoot when player shoots
            shootFromSatellites();

            // Quad ships shoot when player shoots
            shootFromQuadShips();

            playShootSound();
        }

        // Update bullets
        function updateBullets() {
            if (gameState.paused) return;

            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;

                return bullet.x >= 0 && bullet.x <= canvas.width &&
                       bullet.y >= 0 && bullet.y <= canvas.height;
            });
        }

        // Draw bullets
        function drawBullets() {
            ctx.fillStyle = '#0ff';
            gameState.bullets.forEach(bullet => {
                ctx.fillRect(bullet.x - 2, bullet.y - 2, 4, 4);
            });
        }

        // Update power-ups
        function updatePowerUps() {
            if (gameState.paused) return;

            const px = centerX + Math.cos(gameState.player.angle) * gameState.player.orbitRadius;
            const py = centerY + Math.sin(gameState.player.angle) * gameState.player.orbitRadius;

            gameState.powerUps = gameState.powerUps.filter(powerUp => {
                // Calculate direction toward Earth center (straight line)
                const dxEarth = centerX - powerUp.x;
                const dyEarth = centerY - powerUp.y;
                const distToEarth = Math.sqrt(dxEarth * dxEarth + dyEarth * dyEarth);

                // Move in straight line toward Earth (life bonuses and superweapons move at half speed)
                const speed = (powerUp.isLifeBonus || powerUp.isSuperweapon) ? 2.0 : 4.0;
                if (distToEarth > 0) {
                    powerUp.x += (dxEarth / distToEarth) * speed * deltaTime;
                    powerUp.y += (dyEarth / distToEarth) * speed * deltaTime;
                }

                // Check collision with player
                const dxPlayer = px - powerUp.x;
                const dyPlayer = py - powerUp.y;
                const distToPlayer = Math.sqrt(dxPlayer * dxPlayer + dyPlayer * dyPlayer);

                if (distToPlayer < 15) {
                    collectPowerUp(powerUp);
                    return false;
                }

                // Power-ups that reach Earth center
                if (distToEarth < 40) {
                    // Superweapons and lives auto-collect when reaching Earth
                    if (powerUp.isSuperweapon || powerUp.isLifeBonus) {
                        collectPowerUp(powerUp);
                    }
                    return false;
                }

                return true;
            });
        }

        // Draw power-ups (minimal animation to prevent flashing)
        function drawPowerUps() {
            const time = Date.now();

            gameState.powerUps.forEach(powerUp => {
                ctx.save();
                ctx.translate(powerUp.x, powerUp.y);

                const isSuperweapon = powerUp.isSuperweapon;
                const isLifeBonus = powerUp.isLifeBonus;

                if (isLifeBonus) {
                    // Life bonus: pulsing "L" in a yellow solid circle
                    const pulse = Math.sin(time * 0.006) * 0.2 + 1.0;
                    const size = 12 * pulse;

                    // Pulsing outer glow (yellow)
                    const glowSize = size + 6;
                    const gradient = ctx.createRadialGradient(0, 0, size - 2, 0, 0, glowSize);
                    gradient.addColorStop(0, '#ffff00ff');
                    gradient.addColorStop(0.5, '#ffff0066');
                    gradient.addColorStop(1, '#ffff0000');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Solid yellow circle background
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();

                    // White border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.stroke();

                    // "L" label
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('L', 0, 1);
                } else if (isSuperweapon) {
                    // Superweapon pack: bright pulsing icon with number 1-5
                    const pulse = Math.sin(time * 0.008) * 0.25 + 1.0;
                    const size = 14 * pulse;

                    // Rainbow color cycling for extra brightness
                    const hue = (time * 0.1) % 360;
                    const brightColor = `hsl(${hue}, 100%, 60%)`;
                    const glowColor = `hsl(${hue}, 100%, 50%)`;

                    // Intense outer glow
                    const glowSize = size + 10;
                    const gradient = ctx.createRadialGradient(0, 0, size - 2, 0, 0, glowSize);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, brightColor);
                    gradient.addColorStop(0.7, glowColor + '66');
                    gradient.addColorStop(1, glowColor + '00');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Bright white/colored circle background
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.fill();

                    // Colored border
                    ctx.strokeStyle = brightColor;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, size, 0, Math.PI * 2);
                    ctx.stroke();

                    // Number label (1-5)
                    const num = powerUp.superweaponCount || 1;
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 16px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(num.toString(), 0, 1);
                } else {
                    // Regular power-up: static square box
                    const glowSize = 16;
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                    gradient.addColorStop(0, powerUp.color + '88');
                    gradient.addColorStop(0.6, powerUp.color + '33');
                    gradient.addColorStop(1, powerUp.color + '00');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
                    ctx.fill();

                    // Very slow rotation (barely noticeable)
                    const angle = time * 0.0005;
                    ctx.rotate(angle);

                    const size = 8;

                    // Main box
                    ctx.fillStyle = powerUp.color;
                    ctx.fillRect(-size, -size, size * 2, size * 2);

                    // Inner highlight (static)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(-size * 0.5, -size * 0.5, size, size);

                    // Outer border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-size, -size, size * 2, size * 2);

                    // Label
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(powerUp.label, 0, 0);
                }

                ctx.restore();
            });
        }

        // Apply power-up
        // Flash a status bar to highlight changes
        function flashStatusBar(barIndex) {
            const statusBars = document.querySelectorAll('.status-bar');
            if (statusBars[barIndex]) {
                const bar = statusBars[barIndex];
                bar.classList.remove('flash');
                // Force reflow to restart animation
                void bar.offsetWidth;
                bar.classList.add('flash');
                setTimeout(() => bar.classList.remove('flash'), 500);
            }
        }

        // Collect a power-up (handles superweapon packs specially)
        function collectPowerUp(powerUp) {
            if (powerUp.type === 'superweapon_pack') {
                // Give N random superweapons based on the number shown
                const count = powerUp.superweaponCount || 1;
                const superweaponIds = ['shield', 'hyperkill', 'satellites', 'quad', 'rockets'];
                for (let i = 0; i < count; i++) {
                    const randomId = superweaponIds[Math.floor(Math.random() * superweaponIds.length)];
                    giveSuperweapon(randomId);
                }
                // Set cooldown to prevent accidental trigger (~1 second at 60fps)
                gameState.superweaponCooldown = 60;
                showLevelMessage(`+${count} SUPERWEAPON${count > 1 ? 'S' : ''}!`);
                flashStatusBar(6);
                playPowerUpSound();
            } else {
                applyPowerUp(powerUp.type);
                playPowerUpSound();
            }
        }

        function applyPowerUp(type) {
            if (type === 'speed') {
                // Stackable speed increases (more noticeable)
                const speedInc = gameConfig.player.rotationSpeedIncrement;
                gameState.player.speed += speedInc;
                gameState.player.baseSpeed += speedInc;
                const speedLevel = Math.round((gameState.player.speed - gameConfig.player.startingRotationSpeed) / speedInc) + 1;
                showLevelMessage(`SPEED UP! LVL ${speedLevel}`);
                flashStatusBar(3); // Speed bar
            } else if (type === 'double') {
                if (gameState.player.bulletMode < 2) {
                    gameState.player.bulletMode = 2;
                    showLevelMessage('DOUBLE SHOT!');
                    flashStatusBar(4); // Firepower bar
                }
            } else if (type === 'triple') {
                if (gameState.player.bulletMode < 3) {
                    gameState.player.bulletMode = 3;
                    showLevelMessage('TRIPLE SHOT!');
                    flashStatusBar(4); // Firepower bar
                }
            } else if (type === 'quadruple') {
                if (gameState.player.bulletMode < 4) {
                    gameState.player.bulletMode = 4;
                    showLevelMessage('QUAD SHOT!');
                    flashStatusBar(4); // Firepower bar
                }
            } else if (type === 'quintuple') {
                if (gameState.player.bulletMode < 5) {
                    gameState.player.bulletMode = 5;
                    showLevelMessage('QUINTUPLE SHOT!');
                    flashStatusBar(4); // Firepower bar
                }
            } else if (type === 'firerate') {
                // Decrease cooldown by increment, down to minimum
                const oldTime = gameState.player.shootCooldownTime;
                const increment = gameConfig.player.fireRateIncrement; // Negative value
                const minRate = gameConfig.player.minFireRate;
                gameState.player.shootCooldownTime = Math.max(minRate, gameState.player.shootCooldownTime + increment);
                if (gameState.player.shootCooldownTime < oldTime) {
                    const startRate = gameConfig.player.startingFireRate;
                    const fireLevel = Math.round((startRate - gameState.player.shootCooldownTime) / Math.abs(increment)) + 1;
                    showLevelMessage(`FIRE RATE UP! LVL ${fireLevel}`);
                    flashStatusBar(4); // Firepower bar
                }
            } else if (type === 'bulletspeed') {
                // Increase bullet speed by increment, up to max
                const oldSpeed = gameState.player.bulletSpeed;
                const bsIncrement = gameConfig.player.bulletSpeedIncrement;
                gameState.player.bulletSpeed = Math.min(gameState.player.bulletSpeed + bsIncrement, gameConfig.player.maxBulletSpeed);
                if (gameState.player.bulletSpeed > oldSpeed) {
                    const bulletLevel = Math.round((gameState.player.bulletSpeed - gameConfig.player.startingBulletSpeed) / bsIncrement) + 1;
                    showLevelMessage(`BULLET SPEED UP! LVL ${bulletLevel}`);
                    flashStatusBar(5); // Shotspeed bar
                }
            } else if (type === 'earthhealth') {
                gameState.earthHealth = Math.min(gameState.earthHealth + 5, gameConfig.player.maxEarthHealth);
                showLevelMessage('EARTH HEALTH +5!');
                flashStatusBar(2); // Earth HP bar
                updateUI();
            } else if (type === 'extralife') {
                gameState.lives = Math.min(gameState.lives + 1, gameConfig.player.maxLives);
                showLevelMessage('EXTRA LIFE!');
                flashStatusBar(1); // Lives bar
                playExtraLifeSound();
                updateUI();
            } else if (type === 'lifebonus') {
                // Life bonus pickup (one per level)
                gameState.lives = Math.min(gameState.lives + 1, gameConfig.player.maxLives);
                showLevelMessage('EXTRA LIFE!');
                flashStatusBar(1); // Lives bar
                playExtraLifeSound();
                updateUI();
            } else if (type === 'mirrorship') {
                activateMirrorShip();
                showLevelMessage('MIRROR SHIP! 30s');
                flashStatusBar(6); // Superpowers bar
            } else if (type === 'hyperkill') {
                // Now handled by superweapon system
                giveSuperweapon('hyperkill');
                flashStatusBar(6); // Superpowers bar
            } else if (type === 'shield') {
                giveSuperweapon('shield');
                flashStatusBar(6); // Superpowers bar
            } else if (type === 'satellites') {
                giveSuperweapon('satellites');
                flashStatusBar(6); // Superpowers bar
            } else if (type === 'quad') {
                giveSuperweapon('quad');
                flashStatusBar(6); // Superpowers bar
            } else if (type === 'rockets') {
                giveSuperweapon('rockets');
                flashStatusBar(6); // Superpowers bar
            }
        }

        // Spawn alien
        function spawnAlien() {
            const type = selectRandomAlienType();
            if (!type) return; // Don't spawn if no alien types available

            const angle = Math.random() * Math.PI * 2;
            const distance = canvas.width * 0.5;

            const alien = {
                x: centerX + Math.cos(angle) * distance,
                y: centerY + Math.sin(angle) * distance,
                type: type,
                health: type.health,
                maxHealth: type.health,
                timeAlive: 0, // Track for movement patterns
                wobbleOffset: Math.random() * Math.PI * 2, // Random phase for wobble
                orbitDistance: distance // Track for orbital movement
            };

            gameState.aliens.push(alien);
        }

        // Spawn bonus ship
        function spawnBonusShip() {
            if (!alienTypes || alienTypes.length === 0) return;
            const bonusType = alienTypes.find(t => t.isBonus); // Rainbow bonus ship
            if (!bonusType) return;

            const angle = Math.random() * Math.PI * 2;
            const distance = canvas.width * 0.5;

            const alien = {
                x: centerX + Math.cos(angle) * distance,
                y: centerY + Math.sin(angle) * distance,
                type: bonusType,
                health: bonusType.health,
                maxHealth: bonusType.health,
                timeAlive: 0,
                wobbleOffset: Math.random() * Math.PI * 2,
                orbitDistance: distance
            };

            gameState.aliens.push(alien);
        }

        // Update aliens
        function updateAliens() {
            if (gameState.paused) return;

            gameState.alienSpawnTimer += deltaTime;

            // Get spawn rate from level config
            const levelConfig = getCurrentLevelConfig();
            const adjustedSpawnRate = levelConfig ? levelConfig.spawnRate : 120;

            if (gameState.alienSpawnTimer >= adjustedSpawnRate) {
                spawnAlien();
                gameState.alienSpawnTimer = 0;
            }

            // Bonus ship spawns based on kills from level config
            const killsPerBonus = levelConfig && levelConfig.bonusSpawnKillInterval !== null
                ? levelConfig.bonusSpawnKillInterval
                : 99999;

            // Track last bonus spawn kill count
            if (!gameState.lastBonusKillCount) {
                gameState.lastBonusKillCount = 0;
            }

            if (gameState.wave > 1 && gameState.waveKills - gameState.lastBonusKillCount >= killsPerBonus) {
                spawnBonusShip();
                gameState.lastBonusKillCount = gameState.waveKills;
            }

            gameState.aliens = gameState.aliens.filter(alien => {
                alien.timeAlive += deltaTime;
                const dx = centerX - alien.x;
                const dy = centerY - alien.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Speed multiplier from level config
                const speedMultiplier = levelConfig ? levelConfig.speedMultiplier : 1.0;
                const speed = alien.type.baseSpeed * speedMultiplier;

                // Different movement patterns based on flightPattern property
                const pattern = alien.type.flightPattern || 'straight_wobble';
                const patternConfig = gameConfig.flightPatterns[pattern];
                const params = patternConfig ? patternConfig.parameters : {};

                if (pattern === 'zigzag') {
                    // Zigzag: sine wave perpendicular to movement
                    const baseVx = (dx / dist) * speed;
                    const baseVy = (dy / dist) * speed;
                    const perpX = -baseVy; // Perpendicular vector
                    const perpY = baseVx;
                    const wobbleAmp = params.wobbleAmplitude || 0.8;
                    const wobbleFreq = params.wobbleFrequency || 0.1;
                    const wobble = Math.sin(alien.timeAlive * wobbleFreq + alien.wobbleOffset) * wobbleAmp;
                    alien.x += (baseVx + perpX * wobble) * deltaTime;
                    alien.y += (baseVy + perpY * wobble) * deltaTime;
                } else if (pattern === 'spiral') {
                    // Spiral inward
                    const orbitSpeed = params.orbitSpeed || 0.02;
                    const inwardMult = params.inwardSpeedMultiplier || 0.5;
                    const angle = Math.atan2(alien.y - centerY, alien.x - centerX) + orbitSpeed * deltaTime;
                    alien.orbitDistance -= speed * inwardMult * deltaTime;
                    alien.x = centerX + Math.cos(angle) * alien.orbitDistance;
                    alien.y = centerY + Math.sin(angle) * alien.orbitDistance;
                } else if (pattern === 'teleport') {
                    // Teleport closer periodically
                    const jumpInterval = params.jumpInterval || 90;
                    const jumpDist = params.jumpDistance || 60;
                    const driftMult = params.driftSpeedMultiplier || 0.3;
                    if (Math.floor(alien.timeAlive) % jumpInterval === 0 && Math.floor(alien.timeAlive - deltaTime) % jumpInterval !== 0) {
                        alien.x += (dx / dist) * jumpDist;
                        alien.y += (dy / dist) * jumpDist;
                    } else {
                        // Slow drift between jumps
                        alien.x += (dx / dist) * speed * driftMult * deltaTime;
                        alien.y += (dy / dist) * speed * driftMult * deltaTime;
                    }
                } else if (pattern === 'swave') {
                    // S-wave approach
                    const baseVx = (dx / dist) * speed;
                    const baseVy = (dy / dist) * speed;
                    const perpX = -baseVy;
                    const perpY = baseVx;
                    const wobbleAmp = params.wobbleAmplitude || 1.2;
                    const wobbleFreq = params.wobbleFrequency || 0.03;
                    const sWave = Math.sin(alien.timeAlive * wobbleFreq + alien.wobbleOffset) * wobbleAmp;
                    alien.x += (baseVx + perpX * sWave) * deltaTime;
                    alien.y += (baseVy + perpY * sWave) * deltaTime;
                } else if (pattern === 'slow_drift') {
                    // Slow drift with course corrections
                    const recalcInterval = params.recalculateInterval || 120;
                    const speedMult = params.speedMultiplier || 0.7;
                    if (Math.floor(alien.timeAlive) % recalcInterval === 0 && Math.floor(alien.timeAlive - deltaTime) % recalcInterval !== 0) {
                        alien.targetAngle = Math.atan2(dy, dx);
                    }
                    if (!alien.targetAngle) alien.targetAngle = Math.atan2(dy, dx);
                    alien.x += Math.cos(alien.targetAngle) * speed * speedMult * deltaTime;
                    alien.y += Math.sin(alien.targetAngle) * speed * speedMult * deltaTime;
                } else if (pattern === 'kamikaze') {
                    // Straight aggressive charge
                    const speedMult = params.speedMultiplier || 1.2;
                    alien.x += (dx / dist) * speed * speedMult * deltaTime;
                    alien.y += (dy / dist) * speed * speedMult * deltaTime;
                } else if (pattern === 'straight') {
                    // Pure straight line - no wobble
                    alien.x += (dx / dist) * speed * deltaTime;
                    alien.y += (dy / dist) * speed * deltaTime;
                } else if (pattern === 'random_drift') {
                    // Wander randomly with slow Earth bias
                    const wanderStrength = params.wanderStrength || 0.5;
                    const earthBias = params.earthBias || 0.15;
                    const changeInterval = params.directionChangeInterval || 60;

                    // Initialize or update random direction
                    if (!alien.wanderAngle || Math.floor(alien.timeAlive) % changeInterval === 0 && Math.floor(alien.timeAlive - deltaTime) % changeInterval !== 0) {
                        alien.wanderAngle = Math.random() * Math.PI * 2;
                    }

                    // Combine random wander with Earth bias
                    const wanderVx = Math.cos(alien.wanderAngle) * speed * wanderStrength;
                    const wanderVy = Math.sin(alien.wanderAngle) * speed * wanderStrength;
                    const biasVx = (dx / dist) * speed * earthBias;
                    const biasVy = (dy / dist) * speed * earthBias;

                    alien.x += (wanderVx + biasVx) * deltaTime;
                    alien.y += (wanderVy + biasVy) * deltaTime;
                } else if (pattern === 'two_step') {
                    // Two steps forward, one step back
                    const forwardFrames = params.forwardFrames || 40;
                    const backwardFrames = params.backwardFrames || 20;
                    const backMult = params.backwardSpeedMultiplier || 0.6;
                    const cycleLength = forwardFrames + backwardFrames;
                    const cyclePos = Math.floor(alien.timeAlive) % cycleLength;

                    if (cyclePos < forwardFrames) {
                        // Moving forward
                        alien.x += (dx / dist) * speed * deltaTime;
                        alien.y += (dy / dist) * speed * deltaTime;
                    } else {
                        // Moving backward
                        alien.x -= (dx / dist) * speed * backMult * deltaTime;
                        alien.y -= (dy / dist) * speed * backMult * deltaTime;
                    }
                } else if (pattern === 'stop_and_go') {
                    // Move in, pause, sidestep, pause, repeat
                    const moveFrames = params.moveFrames || 30;
                    const pauseFrames = params.pauseFrames || 20;
                    const sidestepFrames = params.sidestepFrames || 25;
                    const sidestepDist = params.sidestepDistance || 40;
                    const cycleLength = moveFrames + pauseFrames + sidestepFrames + pauseFrames;
                    const cyclePos = Math.floor(alien.timeAlive) % cycleLength;

                    if (cyclePos < moveFrames) {
                        // Moving toward Earth
                        alien.x += (dx / dist) * speed * deltaTime;
                        alien.y += (dy / dist) * speed * deltaTime;
                    } else if (cyclePos < moveFrames + pauseFrames) {
                        // First pause - do nothing
                    } else if (cyclePos < moveFrames + pauseFrames + sidestepFrames) {
                        // Sidestep (perpendicular to Earth direction)
                        const perpX = -dy / dist;
                        const perpY = dx / dist;
                        const sideDir = alien.wobbleOffset > Math.PI ? 1 : -1; // Use wobbleOffset to determine direction
                        alien.x += perpX * speed * sideDir * deltaTime;
                        alien.y += perpY * speed * sideDir * deltaTime;
                    }
                    // else: second pause - do nothing
                } else {
                    // Default: straight_wobble
                    const baseVx = (dx / dist) * speed;
                    const baseVy = (dy / dist) * speed;
                    const wobbleAmp = params.wobbleAmplitude || 0.8;
                    const wobbleFreq = params.wobbleFrequency || 0.1;
                    const wobble = Math.sin(alien.timeAlive * wobbleFreq + alien.wobbleOffset) * wobbleAmp;
                    const perpX = -baseVy;
                    const perpY = baseVx;
                    alien.x += (baseVx + perpX * wobble) * deltaTime;
                    alien.y += (baseVy + perpY * wobble) * deltaTime;
                }

                if (dist < 40) {
                    gameState.earthHealth--;
                    playCrashSound();
                    updateUI();

                    if (gameState.earthHealth <= 0) {
                        endGame('EARTH DESTROYED');
                    }

                    return false;
                }

                return true;
            });
        }

        // Draw aliens (no health bars)
        function drawAliens() {
            gameState.aliens.forEach(alien => {
                draw8BitAlien(alien.x, alien.y, alien.type);
            });
        }

        // Check collisions
        function checkCollisions() {
            if (gameState.paused) return;

            // Bullet collisions
            gameState.bullets = gameState.bullets.filter(bullet => {
                let bulletAlive = true;

                gameState.aliens = gameState.aliens.filter(alien => {
                    if (!bulletAlive) return true;

                    const dx = bullet.x - alien.x;
                    const dy = bullet.y - alien.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < alien.type.size + bullet.size) {
                        alien.health--;
                        bulletAlive = false;

                        if (alien.health <= 0) {
                            // Create explosion particles
                            createAlienExplosion(alien.x, alien.y, alien.type);

                            // Play appropriate explosion sound based on alien type
                            if (alien.type.isBonus) {
                                playBonusExplosionSound();
                            } else if (alien.type.health === 1) {
                                playSmallExplosionSound();
                            } else if (alien.type.health === 2) {
                                playMediumExplosionSound();
                            } else {
                                playLargeExplosionSound();
                            }

                            gameState.score += alien.type.points;

                            // Drop power-up if bonus ship
                            if (alien.type.isBonus) {
                                dropPowerUp(alien.x, alien.y);
                            } else {
                                // Only count non-bonus aliens toward wave target
                                gameState.waveKills++;
                                checkSuperweaponSpawn();
                                checkLifeBonusSpawn();
                            }

                            updateUI();

                            if (gameState.waveKills >= gameState.waveTarget) {
                                nextWave();
                            }

                            return false;
                        }
                    }

                    return true;
                });

                return bulletAlive;
            });
        }

        // Get available power-ups based on level
        function getAvailablePowerUps() {
            return powerUpTypes.filter(p => p.unlockLevel <= gameState.wave);
        }

        // Get power-up drop weights based on level
        function getPowerUpWeights() {
            const available = getAvailablePowerUps();
            const weights = [];

            available.forEach(powerUp => {
                let weight = 10; // Base weight

                // Filter out already-owned/maxed power-ups
                if (powerUp.type === 'double' && gameState.player.bulletMode >= 2) weight = 0;
                if (powerUp.type === 'triple' && gameState.player.bulletMode >= 3) weight = 0;
                if (powerUp.type === 'quadruple' && gameState.player.bulletMode >= 4) weight = 0;
                if (powerUp.type === 'quintuple' && gameState.player.bulletMode >= gameConfig.player.maxBulletMode) weight = 0;
                if (powerUp.type === 'firerate' && gameState.player.shootCooldownTime <= gameConfig.player.minFireRate) weight = 0;
                if (powerUp.type === 'speed' && gameState.player.speed >= gameConfig.player.maxRotationSpeed) weight = 0;
                if (powerUp.type === 'bulletspeed' && gameState.player.bulletSpeed >= gameConfig.player.maxBulletSpeed) weight = 0;
                if (powerUp.type === 'extralife' && gameState.lives >= gameConfig.player.maxLives) weight = 0;
                if (powerUp.type === 'earthhealth' && gameState.earthHealth >= gameConfig.player.maxEarthHealth) weight = 0;
                // Superweapons are spawned separately - not in regular power-up pool
                if (['shield', 'hyperkill', 'satellites', 'quad', 'rockets'].includes(powerUp.type)) weight = 0;

                // Level 1-5: Basic power-ups
                if (gameState.wave <= 5) {
                    if (powerUp.type === 'speed') weight = 30;
                    else if (powerUp.type === 'double') weight = 25;
                    else if (powerUp.type === 'firerate') weight = 25;
                    else if (powerUp.type === 'bulletspeed') weight = 25;
                    else if (powerUp.type === 'earthhealth') weight = 8;
                }
                // Level 6-10: Firepower phase
                else if (gameState.wave <= 10) {
                    if (powerUp.type === 'speed') weight = 25;
                    else if (powerUp.type === 'firerate') weight = 25;
                    else if (powerUp.type === 'bulletspeed') weight = 25;
                    else if (powerUp.type === 'double' || powerUp.type === 'triple') weight = 20;
                    else if (powerUp.type === 'earthhealth') weight = 10;
                }
                // Level 11-15: Strategic phase (quad unlocks at 12)
                else if (gameState.wave <= 15) {
                    if (powerUp.type === 'firerate') weight = 25;
                    else if (powerUp.type === 'bulletspeed') weight = 23;
                    else if (powerUp.type === 'speed') weight = 22;
                    else if (powerUp.type === 'quadruple') weight = 20;
                    else if (powerUp.type === 'earthhealth') weight = 12;
                    else if (powerUp.type === 'extralife') weight = 8;
                    else if (powerUp.type === 'mirrorship') weight = 8;
                    else weight = 5;
                }
                // Level 16-20: Endgame (quint unlocks at 16)
                else {
                    if (powerUp.type === 'firerate') weight = 30;
                    else if (powerUp.type === 'quintuple') weight = 25;
                    else if (powerUp.type === 'bulletspeed') weight = 22;
                    else if (powerUp.type === 'speed') weight = 20;
                    else if (powerUp.type === 'extralife') weight = 15;
                    else if (powerUp.type === 'mirrorship') weight = 10;
                    else if (powerUp.type === 'earthhealth') weight = 8;
                    else weight = 5;
                }

                weights.push({ powerUp, weight });
            });

            return weights;
        }

        // Select random power-up based on weights
        function selectRandomPowerUp() {
            const weights = getPowerUpWeights();
            if (weights.length === 0) return null; // Safety check
            const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
            if (totalWeight === 0) return weights[0].powerUp; // If all weights are 0, return first
            let random = Math.random() * totalWeight;

            for (let w of weights) {
                random -= w.weight;
                if (random <= 0) return w.powerUp;
            }

            return weights[0].powerUp;
        }

        // Drop power-up
        function dropPowerUp(x, y) {
            const powerUp = selectRandomPowerUp();
            if (!powerUp) return; // Safety check - don't drop if no power-ups available

            gameState.powerUps.push({
                x: x,
                y: y,
                type: powerUp.type,
                color: powerUp.color,
                label: powerUp.label
            });
        }

        // Spawn superweapon power-up (multiple per level on higher waves)
        function spawnSuperweaponPowerUp() {
            if (gameState.wave < 5) return;
            // Check if we've spawned all superweapons for this wave
            if (gameState.superweaponSpawnsThisWave >= gameState.superweaponSpawnTargets.length) return;

            // Random number 1-5 determines how many superweapons you get
            const superweaponCount = Math.floor(Math.random() * 5) + 1;

            // Spawn at random position at edge of screen
            const angle = Math.random() * Math.PI * 2;
            const distance = 280; // Near edge of canvas
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance;

            gameState.powerUps.push({
                x: x,
                y: y,
                type: 'superweapon_pack',
                superweaponCount: superweaponCount,
                isSuperweapon: true
            });

            gameState.superweaponSpawnsThisWave++;
            showLevelMessage('SUPERWEAPON!');
        }

        // Check if superweapon should spawn based on kill progress
        function checkSuperweaponSpawn() {
            if (gameState.wave < 5) return;
            // Check if we've spawned all for this wave
            if (gameState.superweaponSpawnsThisWave >= gameState.superweaponSpawnTargets.length) return;
            // Check if we've reached the next spawn target
            const nextTarget = gameState.superweaponSpawnTargets[gameState.superweaponSpawnsThisWave];
            if (gameState.waveKills >= nextTarget) {
                spawnSuperweaponPowerUp();
            }
        }

        // Spawn life bonus power-up (one per level, separate from regular drops)
        function spawnLifeBonusPowerUp() {
            if (gameState.lifeBonusSpawnedThisWave) return;
            if (gameState.lives >= gameConfig.player.maxLives) return; // Already at max lives

            // Spawn at random position at edge of screen
            const angle = Math.random() * Math.PI * 2;
            const distance = 280; // Near edge of canvas
            const x = centerX + Math.cos(angle) * distance;
            const y = centerY + Math.sin(angle) * distance;

            gameState.powerUps.push({
                x: x,
                y: y,
                type: 'lifebonus',
                color: '#ffff00',
                label: 'L',
                isLifeBonus: true
            });

            gameState.lifeBonusSpawnedThisWave = true;
        }

        // Check if life bonus should spawn based on kill progress
        function checkLifeBonusSpawn() {
            if (gameState.wave < 3) return; // Life bonuses start on level 3
            if (gameState.lifeBonusSpawnedThisWave) return;
            if (gameState.waveKills >= gameState.lifeBonusSpawnKillTarget) {
                spawnLifeBonusPowerUp();
            }
        }

        // Show level message
        function showLevelMessage(message) {
            const msgEl = document.getElementById('levelMessage');
            msgEl.textContent = message;
            msgEl.classList.add('show');
            setTimeout(() => {
                msgEl.classList.remove('show');
            }, 2000);
        }

        // Next wave
        function nextWave() {
            gameState.paused = true;
            stopBackgroundMusic();

            // Show completion message
            showLevelMessage(`WAVE ${gameState.wave} COMPLETE!`);

            // Play celebratory jingle immediately
            playLevelCompleteSound();

            // Wait for jingle to finish (1.5s) + brief silence (0.5s)
            setTimeout(() => {
                gameState.wave++;

                // Check if game is won (completed level 20)
                if (gameState.wave > 20) {
                    gameWon();
                    return;
                }

                gameState.waveKills = 0;
                gameState.lastBonusKillCount = 0;
                // Get wave target from level config
                const newLevelConfig = getCurrentLevelConfig();
                gameState.waveTarget = newLevelConfig ? newLevelConfig.aliensToKill : 8;

                // Reset superweapon spawn tracking for new wave (multiple spawns on higher levels)
                gameState.superweaponSpawnsThisWave = 0;
                gameState.superweaponSpawnTargets = [];
                if (gameState.wave >= 5) {
                    // Determine how many superweapons spawn this wave
                    let numSpawns = 1;
                    if (gameState.wave >= 15) numSpawns = 3;
                    else if (gameState.wave >= 10) numSpawns = 2;

                    // Set kill targets spread across the wave
                    for (let i = 0; i < numSpawns; i++) {
                        const startPercent = 0.20 + (i * 0.25); // 20%, 45%, 70%
                        const endPercent = startPercent + 0.15;
                        const minKills = Math.floor(gameState.waveTarget * startPercent);
                        const maxKills = Math.floor(gameState.waveTarget * endPercent);
                        gameState.superweaponSpawnTargets.push(minKills + Math.floor(Math.random() * (maxKills - minKills + 1)));
                    }
                }

                // Reset life bonus spawn tracking for new wave (spawns at 50-75% of kills)
                gameState.lifeBonusSpawnedThisWave = false;
                const lifeMinKills = Math.floor(gameState.waveTarget * 0.50);
                const lifeMaxKills = Math.floor(gameState.waveTarget * 0.75);
                gameState.lifeBonusSpawnKillTarget = lifeMinKills + Math.floor(Math.random() * (lifeMaxKills - lifeMinKills + 1));

                // Reset auto-fire to full charge for new wave
                gameState.autoFireCharge = gameState.autoFireMaxCharge;
                gameState.autoFireAvailable = true;
                gameState.autoFireActive = false;
                updateAutoFireUI();

                // Clear all entities from the screen at level end
                gameState.aliens = [];
                gameState.bullets = [];
                gameState.powerUps = [];
                // Reset superweapon pickup counter for new level
                gameState.superweaponPickupsThisLevel = 0;
                gameState.explosionParticles = [];
                gameState.medPacks = [];
                gameState.medShip = null;
                gameState.medShipAppearedThisWave = false;
                updateUI();

                // Show new wave message
                showLevelMessage(`WAVE ${gameState.wave}`);

                // Wait before starting music (1.5s)
                setTimeout(() => {
                    gameState.paused = false;
                    // Set music track for new level (cycle through classical tracks)
                    currentMusicTrack = (gameState.wave - 1) % 5;
                    startBackgroundMusic();
                }, 1500);
            }, 2000);
        }

        // Update UI
        let lastScore = 0;
        function updateUI() {
            const scoreElement = document.getElementById('score');
            const scoreBox = document.getElementById('scoreBox');

            // Update score with animation when it increases
            if (gameState.score > lastScore) {
                scoreElement.textContent = gameState.score;
                scoreBox.classList.remove('pulse');
                void scoreBox.offsetWidth; // Trigger reflow
                scoreBox.classList.add('pulse');
                lastScore = gameState.score;
            } else {
                scoreElement.textContent = gameState.score;
                lastScore = gameState.score;
            }
        }

        // Update auto-fire UI indicator
        function updateAutoFireUI() {
            const indicator = document.getElementById('autoFireIndicator');
            const bar = document.getElementById('autoFireBar');
            if (!indicator || !bar) return;

            const chargePercent = (gameState.autoFireCharge / gameState.autoFireMaxCharge) * 100;
            bar.style.width = chargePercent + '%';

            indicator.classList.remove('available', 'active', 'recharging', 'disabled');

            // Auto-fire disabled for first 3 waves
            if (gameState.wave <= 3) {
                indicator.classList.add('disabled');
            } else if (gameState.autoFireActive) {
                indicator.classList.add('active');
            } else if (gameState.autoFireAvailable) {
                indicator.classList.add('available');
            } else {
                indicator.classList.add('recharging');
            }
        }

        // Update status bars
        function updateStatusBars() {
            // Wave bar: 1 (min) to 20 (max)
            const wavePercent = ((gameState.wave - 1) / 19) * 100;
            document.getElementById('waveBar').style.width = wavePercent + '%';
            document.getElementById('wavePercent').textContent = Math.round(wavePercent) + '%';

            // Lives bar: 0 (min) to maxLives (max)
            const livesPercent = (gameState.lives / gameConfig.player.maxLives) * 100;
            document.getElementById('livesBar').style.width = livesPercent + '%';
            document.getElementById('livesPercent').textContent = Math.round(livesPercent) + '%';

            // Health bar: 0 (min) to maxEarthHealth (max)
            const healthPercent = (gameState.earthHealth / gameConfig.player.maxEarthHealth) * 100;
            document.getElementById('healthBar').style.width = healthPercent + '%';
            document.getElementById('healthPercent').textContent = Math.round(healthPercent) + '%';

            // Speed bar: startingRotationSpeed (min) to maxRotationSpeed (max)
            const minSpeed = gameConfig.player.startingRotationSpeed;
            const maxSpeed = gameConfig.player.maxRotationSpeed;
            const speedPercent = Math.min(100, ((gameState.player.speed - minSpeed) / (maxSpeed - minSpeed)) * 100);
            document.getElementById('speedBar').style.width = speedPercent + '%';
            document.getElementById('speedPercent').textContent = Math.round(speedPercent) + '%';

            // Firepower bar: 1 (single) to maxBulletMode
            const firepowerPercent = ((gameState.player.bulletMode - 1) / (gameConfig.player.maxBulletMode - 1)) * 100;
            document.getElementById('firepowerBar').style.width = firepowerPercent + '%';
            document.getElementById('firepowerPercent').textContent = Math.round(firepowerPercent) + '%';

            // Shotspeed bar: startingFireRate (slowest) to minFireRate (fastest) - inverted
            const maxCooldown = gameConfig.player.startingFireRate;
            const minCooldown = gameConfig.player.minFireRate;
            const shotspeedException = ((maxCooldown - gameState.player.shootCooldownTime) / (maxCooldown - minCooldown)) * 100;
            document.getElementById('shotspeedBar').style.width = shotspeedException + '%';
            document.getElementById('shotspeedPercent').textContent = Math.round(shotspeedException) + '%';

            // Superpowers bar: count total superweapons (10% each, capped at 100%)
            let totalSuperweapons = 0;
            Object.values(gameState.superweapons).forEach(sw => {
                totalSuperweapons += sw.count;
            });
            const superpowerPercent = Math.min(100, totalSuperweapons * 10);
            document.getElementById('superpowersBar').style.width = superpowerPercent + '%';
            document.getElementById('superpowersPercent').textContent = totalSuperweapons > 0 ? `${totalSuperweapons}` : '0';

            // Bullet Speed bar: startingBulletSpeed (min) to maxBulletSpeed (max)
            const minBulletSpeed = gameConfig.player.startingBulletSpeed;
            const maxBulletSpeedVal = gameConfig.player.maxBulletSpeed;
            const bulletSpeedPercent = Math.min(100, ((gameState.player.bulletSpeed - minBulletSpeed) / (maxBulletSpeedVal - minBulletSpeed)) * 100);
            document.getElementById('bulletSpeedBar').style.width = bulletSpeedPercent + '%';
            document.getElementById('bulletSpeedPercent').textContent = Math.round(bulletSpeedPercent) + '%';
        }

        // End game
        function endGame(reason) {
            gameState.gameOver = true;
            stopBackgroundMusic();

            const finalScore = gameState.score;
            const finalWave = gameState.wave;

            document.getElementById('finalScore').textContent = finalScore;
            document.getElementById('finalWave').textContent = finalWave;
            document.getElementById('gameOverReason').textContent = reason || 'GAME OVER';

            // Check if high score
            const highScoreEntryBox = document.getElementById('highScoreEntryBox');
            const highScoreMsg = document.getElementById('highScoreMessage');

            if (isHighScore(finalScore)) {
                // Show flashing box instead of prompting
                highScoreEntryBox.classList.add('show');
                highScoreMsg.textContent = '';
            } else {
                highScoreEntryBox.classList.remove('show');
                highScoreMsg.textContent = '';
                updateLeaderboard();
            }

            document.getElementById('gameOver').classList.add('show');
        }

        // Handle high score name entry when box is clicked
        function enterHighScoreName() {
            const entryBox = document.getElementById('highScoreEntryBox');

            // Prevent multiple prompts
            if (entryBox.dataset.prompted === 'true') return;
            entryBox.dataset.prompted = 'true';

            const finalScore = gameState.score;
            const finalWave = gameState.wave;

            // Prompt for name - Cancel means skip
            let playerName = prompt('NEW HIGH SCORE! Enter your name (max 10 characters):\n\nPress Cancel to skip.');

            // Hide flashing box
            entryBox.classList.remove('show');
            entryBox.dataset.prompted = 'false';

            if (playerName === null) {
                // User cancelled - skip saving high score
                document.getElementById('highScoreMessage').textContent = 'HIGH SCORE NOT SAVED';
                updateLeaderboard();
                return;
            }

            if (playerName.trim() === '') {
                playerName = 'PLAYER';
            } else {
                playerName = playerName.trim().toUpperCase().substring(0, 10);
            }

            const highScores = saveHighScore(finalScore, finalWave, playerName);
            const rank = highScores.findIndex(entry => entry.score === finalScore && entry.name === playerName) + 1;

            document.getElementById('highScoreMessage').textContent = `NEW HIGH SCORE! RANK #${rank}`;
            updateLeaderboard(finalScore);
        }

        // Game won (completed level 20)
        // Victory state
        let victoryFireworks = [];
        let victoryAnimationId = null;
        let creditsOffset = 0;

        function gameWon() {
            gameState.gameOver = true;
            gameState.victory = true;
            stopBackgroundMusic();

            const finalScore = gameState.score;

            // Start victory music and fireworks
            playVictoryMusic();
            startVictoryFireworks();

            // Show victory screen with credits
            const gameOverDiv = document.getElementById('gameOver');
            gameOverDiv.innerHTML = `
                <canvas id="fireworksCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                <div id="victoryContent" style="position: relative; z-index: 10;">
                    <div style="color: #ffff00; font-size: 64px; font-weight: bold; margin-bottom: 10px; text-shadow: 0 0 30px #ffff00, 0 0 60px #ff8800;">
                        CONGRATULATIONS!
                    </div>
                    <div style="color: #00ff00; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 20px #00ff00;">
                        EARTH IS SAVED!
                    </div>
                    <div style="color: #ffffff; font-size: 32px; margin-bottom: 30px;">
                        Final Score: <span style="color: #ffff00;">${finalScore.toLocaleString()}</span>
                    </div>
                    <div id="creditsContainer" style="height: 200px; overflow: hidden; margin: 20px auto; width: 400px; border-top: 2px solid #444; border-bottom: 2px solid #444;">
                        <div id="creditsText" style="color: #888; font-size: 16px; line-height: 2; text-align: center;"></div>
                    </div>
                    <div id="victoryHighScore" style="margin-bottom: 20px;"></div>
                    <button onclick="stopVictoryAndRestart()" style="margin: 10px;">PLAY AGAIN</button>
                </div>
            `;

            // Start credits scroll
            startCreditsScroll();

            // Check if high score (delayed to let player enjoy victory)
            setTimeout(() => {
                if (isHighScore(finalScore)) {
                    const hsDiv = document.getElementById('victoryHighScore');
                    hsDiv.innerHTML = '<div class="high-score-entry-box show" onclick="enterVictoryHighScore()" style="display: inline-block;">NEW HIGH SCORE! CLICK TO ENTER NAME</div>';
                }
            }, 3000);

            gameOverDiv.classList.add('show');
        }

        // Victory high score entry
        function enterVictoryHighScore() {
            const finalScore = gameState.score;
            let playerName = prompt('NEW HIGH SCORE! Enter your name (max 10 characters):\n\nPress Cancel to skip.');

            if (playerName === null) {
                document.getElementById('victoryHighScore').innerHTML = '<div style="color: #888;">High score not saved</div>';
                return;
            }

            if (playerName.trim() === '') {
                playerName = 'CHAMPION';
            } else {
                playerName = playerName.trim().toUpperCase().substring(0, 10);
            }

            const highScores = saveHighScore(finalScore, 20, playerName);
            const rank = highScores.findIndex(entry => entry.score === finalScore && entry.name === playerName) + 1;
            document.getElementById('victoryHighScore').innerHTML = `<div style="color: #ffff00; font-size: 24px;">RANK #${rank} - ${playerName}</div>`;
            updateLeaderboard(finalScore);
        }

        // Play victory music (triumphant 8-bit fanfare)
        function playVictoryMusic() {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;

            // Triumphant fanfare melody
            const melody = [
                { note: 523.25, time: 0, dur: 0.15 },     // C
                { note: 659.25, time: 0.15, dur: 0.15 },  // E
                { note: 783.99, time: 0.3, dur: 0.15 },   // G
                { note: 1046.50, time: 0.45, dur: 0.4 },  // High C
                { note: 783.99, time: 0.9, dur: 0.15 },   // G
                { note: 1046.50, time: 1.05, dur: 0.6 },  // High C (hold)
                // Second phrase
                { note: 587.33, time: 1.8, dur: 0.15 },   // D
                { note: 739.99, time: 1.95, dur: 0.15 },  // F#
                { note: 880.00, time: 2.1, dur: 0.15 },   // A
                { note: 1174.66, time: 2.25, dur: 0.4 },  // High D
                { note: 880.00, time: 2.7, dur: 0.15 },   // A
                { note: 1174.66, time: 2.85, dur: 0.6 },  // High D (hold)
                // Final triumphant chord
                { note: 523.25, time: 3.6, dur: 1.0 },    // C
                { note: 659.25, time: 3.6, dur: 1.0 },    // E
                { note: 783.99, time: 3.6, dur: 1.0 },    // G
                { note: 1046.50, time: 3.6, dur: 1.0 },   // High C
            ];

            melody.forEach(n => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.value = n.note;
                gain.gain.setValueAtTime(0.15, now + n.time);
                gain.gain.exponentialDecayTo = 0.01;
                gain.gain.setValueAtTime(0.15, now + n.time);
                gain.gain.linearRampToValueAtTime(0.01, now + n.time + n.dur);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now + n.time);
                osc.stop(now + n.time + n.dur + 0.1);
            });

            // Loop a celebratory background after fanfare
            setTimeout(() => {
                if (gameState.victory) playVictoryLoop();
            }, 4500);
        }

        // Looping victory background music
        function playVictoryLoop() {
            if (!soundEnabled || !gameState.victory) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;
            const notes = [
                { note: 523.25, time: 0 }, { note: 659.25, time: 0.2 },
                { note: 783.99, time: 0.4 }, { note: 659.25, time: 0.6 },
                { note: 523.25, time: 0.8 }, { note: 783.99, time: 1.0 },
                { note: 659.25, time: 1.2 }, { note: 523.25, time: 1.4 },
            ];

            notes.forEach(n => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.value = n.note;
                gain.gain.setValueAtTime(0.08, now + n.time);
                gain.gain.linearRampToValueAtTime(0.01, now + n.time + 0.18);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(now + n.time);
                osc.stop(now + n.time + 0.2);
            });

            setTimeout(() => {
                if (gameState.victory) playVictoryLoop();
            }, 1600);
        }

        // Fireworks system
        function startVictoryFireworks() {
            victoryFireworks = [];
            const fwCanvas = document.getElementById('fireworksCanvas');
            if (!fwCanvas) return;

            fwCanvas.width = 600;
            fwCanvas.height = 600;
            const fwCtx = fwCanvas.getContext('2d');

            function launchFirework() {
                if (!gameState.victory) return;

                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#ff0088'];
                const x = 100 + Math.random() * 400;
                const y = 100 + Math.random() * 200;
                const color = colors[Math.floor(Math.random() * colors.length)];

                // Create explosion particles
                for (let i = 0; i < 30; i++) {
                    const angle = (Math.PI * 2 * i) / 30 + Math.random() * 0.2;
                    const speed = 2 + Math.random() * 3;
                    victoryFireworks.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 60 + Math.random() * 30,
                        maxLife: 90,
                        color: color,
                        size: 2 + Math.random() * 2
                    });
                }

                // Play firework sound
                if (soundEnabled) {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200 + Math.random() * 200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.3);
                }

                // Launch another firework
                setTimeout(launchFirework, 300 + Math.random() * 500);
            }

            function animateFireworks() {
                if (!gameState.victory) return;

                fwCtx.clearRect(0, 0, 600, 600);

                victoryFireworks = victoryFireworks.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05; // gravity
                    p.life--;

                    const alpha = p.life / p.maxLife;
                    fwCtx.globalAlpha = alpha;
                    fwCtx.fillStyle = p.color;
                    fwCtx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);

                    return p.life > 0;
                });

                fwCtx.globalAlpha = 1;
                victoryAnimationId = requestAnimationFrame(animateFireworks);
            }

            // Start fireworks
            launchFirework();
            animateFireworks();
        }

        // Credits scroll
        function startCreditsScroll() {
            const creditsText = document.getElementById('creditsText');
            if (!creditsText) return;

            const credits = [
                '',
                'SPACE DEFENSE',
                '',
                '- - - - - - - - - -',
                '',
                'GAME DESIGN',
                'PLAYER ONE',
                '',
                'PROGRAMMING',
                'CLAUDE AI',
                '',
                'GRAPHICS',
                '8-BIT PIXEL ART',
                '',
                'MUSIC',
                'PROCEDURAL SYNTHESIS',
                '',
                'SOUND EFFECTS',
                'WEB AUDIO API',
                '',
                '- - - - - - - - - -',
                '',
                'SPECIAL THANKS',
                'ALL EARTH DEFENDERS',
                '',
                'YOU SAVED',
                'HUMANITY!',
                '',
                '- - - - - - - - - -',
                '',
                'PLAY AGAIN?',
                '',
                '',
                ''
            ];

            creditsText.innerHTML = credits.join('<br>');
            creditsOffset = 0;

            function scrollCredits() {
                if (!gameState.victory) return;

                creditsOffset += 0.5;
                creditsText.style.transform = `translateY(${200 - creditsOffset}px)`;

                if (creditsOffset < credits.length * 32 + 200) {
                    requestAnimationFrame(scrollCredits);
                } else {
                    // Loop credits
                    creditsOffset = 0;
                    requestAnimationFrame(scrollCredits);
                }
            }

            scrollCredits();
        }

        // Stop victory and restart
        function stopVictoryAndRestart() {
            gameState.victory = false;
            if (victoryAnimationId) {
                cancelAnimationFrame(victoryAnimationId);
            }
            victoryFireworks = [];
            restartGame();
        }

        // Continue game (for testing)
        function continueGame() {
            // Restore lives and health from config
            gameState.lives = gameConfig.player.startingLives;
            gameState.earthHealth = gameConfig.player.startingEarthHealth;
            gameState.gameOver = false;
            gameState.victory = false;
            gameState.gameStarted = true;
            gameState.paused = false;
            gameState.exploding = false;
            gameState.explosionTimer = 0;

            // Hide game over screens
            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('highScoreEntryBox').classList.remove('show');

            // Resume music
            startBackgroundMusic();

            // Update UI
            updateUI();
            updateStatusBars();
        }

        // Restart game
        function restartGame() {
            gameState = {
                score: 0,
                wave: 1,
                earthHealth: gameConfig.player.startingEarthHealth,
                lives: gameConfig.player.startingLives,
                gameOver: false,
                victory: false,
                gameStarted: false,
                paused: false,
                exploding: false,
                explosionTimer: 0,
                player: {
                    angle: 0,
                    orbitRadius: gameConfig.player.orbitRadius,
                    speed: gameConfig.player.startingRotationSpeed,
                    baseSpeed: gameConfig.player.startingRotationSpeed,
                    size: gameConfig.player.shipSize,
                    bulletMode: gameConfig.player.startingBulletMode,
                    bulletSpeed: gameConfig.player.startingBulletSpeed,
                    shootCooldown: 0,
                    shootCooldownTime: gameConfig.player.startingFireRate
                },
                bullets: [],
                aliens: [],
                powerUps: [],
                explosionParticles: [],
                alienSpawnTimer: 94, // Start ready to spawn immediately
                alienSpawnRate: 120,
                bonusSpawnTimer: 0,
                bonusSpawnRate: 900,
                waveKills: 0,
                waveTarget: gameConfig.levels[0].aliensToKill,
                keys: {},
                earthRotation: 0,
                mirrorShip: null,
                // Auto-fire system (5 second use, 5 second recharge)
                autoFireCharge: 300,
                autoFireMaxCharge: 300,
                autoFireAvailable: true,
                autoFireActive: false,
                medShip: null,
                medShipAppearedThisWave: false,
                medShipAppearances: 0,
                medPacks: [],
                // Superweapon spawn tracking (multiple per level on higher waves)
                superweaponSpawnsThisWave: 0,
                superweaponSpawnTargets: [],
                // Life bonus spawn tracking (one per level, spawns between 50-75% kills)
                lifeBonusSpawnedThisWave: false,
                lifeBonusSpawnKillTarget: 0,
                // Superweapons system (count allows stacking multiple of same type)
                superweapons: {
                    shield: { count: 0, key: null, active: false, timer: 0 },
                    hyperkill: { count: 0, key: null },
                    satellites: { count: 0, key: null, active: false, timer: 0 },
                    quad: { count: 0, key: null, active: false, timer: 0 },
                    rockets: { count: 0, key: null, active: false, timer: 0 }
                },
                activeSuperweapon: null,
                superweaponTimer: 0,
                superweaponCooldown: 0,
                satellites: [],
                quadShips: [],
                missiles: [],
                missileFireTimer: 0,
                superweaponPickupsThisLevel: 0
            };

            // Reset superweapon UI
            updateAllSuperweaponButtons();
            updateSuperweaponTimerDisplay();

            document.getElementById('gameOver').classList.remove('show');
            document.getElementById('highScoreEntryBox').classList.remove('show');
            document.getElementById('startScreen').classList.remove('hidden');
            stopBackgroundMusic();
            updateUI();
            updateStatusBars();
            // Reset demo animation
            demoShips = [];
            demoAliens = [];
            demoBullets = [];
        }

        // Draw stars background - cache to prevent redraw flashing
        let starsCanvas = null;
        function initStars() {
            starsCanvas = document.createElement('canvas');
            starsCanvas.width = canvas.width;
            starsCanvas.height = canvas.height;
            const starsCtx = starsCanvas.getContext('2d');

            starsCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 150; i++) {
                const x = (i * 137.5) % canvas.width;
                const y = (i * 197.3) % canvas.height;
                const size = (i % 3) * 0.5 + 0.5;
                starsCtx.fillRect(x, y, size, size);
            }
        }

        function drawStars() {
            if (!starsCanvas) initStars();
            ctx.drawImage(starsCanvas, 0, 0);
        }

        // Demo animation for start screen
        let demoShips = [];
        let demoAliens = [];
        let demoBullets = [];
        let demoTime = 0;

        function initDemoAnimation() {
            // Create 2 demo ships
            demoShips = [
                { angle: 0, orbitRadius: 100, speed: 0.05, size: 12 },
                { angle: Math.PI, orbitRadius: 100, speed: 0.05, size: 12 }
            ];
            // Create some demo aliens
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                demoAliens.push({
                    x: centerX + Math.cos(angle) * 300,
                    y: centerY + Math.sin(angle) * 300,
                    angle: angle,
                    speed: 0.8,
                    size: 10,
                    color: ['#ffff00', '#00ff00', '#ff8800', '#00ffff'][i % 4]
                });
            }
            console.log('Demo animation initialized:', demoShips.length, 'ships,', demoAliens.length, 'aliens');
        }

        function updateDemoAnimation() {
            demoTime += deltaTime;

            // Update ships
            demoShips.forEach(ship => {
                ship.angle += ship.speed * deltaTime;

                // Shoot occasionally
                if (Math.floor(demoTime) % 30 === 0 && Math.floor(demoTime - deltaTime) % 30 !== 0) {
                    const x = centerX + Math.cos(ship.angle) * ship.orbitRadius;
                    const y = centerY + Math.sin(ship.angle) * ship.orbitRadius;
                    demoBullets.push({
                        x: x,
                        y: y,
                        vx: Math.cos(ship.angle) * 4,
                        vy: Math.sin(ship.angle) * 4
                    });
                }
            });

            // Update aliens
            demoAliens.forEach(alien => {
                const dx = centerX - alien.x;
                const dy = centerY - alien.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                alien.x += (dx / dist) * alien.speed * deltaTime;
                alien.y += (dy / dist) * alien.speed * deltaTime;

                // Reset if too close
                if (dist < 100) {
                    const angle = Math.random() * Math.PI * 2;
                    alien.x = centerX + Math.cos(angle) * 300;
                    alien.y = centerY + Math.sin(angle) * 300;
                }
            });

            // Update bullets
            demoBullets = demoBullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                return bullet.x > 0 && bullet.x < canvas.width && bullet.y > 0 && bullet.y < canvas.height;
            });
        }

        function drawDemoAnimation() {
            // Draw ships
            demoShips.forEach(ship => {
                const x = centerX + Math.cos(ship.angle) * ship.orbitRadius;
                const y = centerY + Math.sin(ship.angle) * ship.orbitRadius;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(ship.angle + Math.PI / 2);

                // Simple ship shape
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(0, -ship.size);
                ctx.lineTo(-ship.size * 0.6, ship.size * 0.5);
                ctx.lineTo(0, ship.size * 0.2);
                ctx.lineTo(ship.size * 0.6, ship.size * 0.5);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            });

            // Draw aliens
            demoAliens.forEach(alien => {
                ctx.fillStyle = alien.color;
                ctx.fillRect(alien.x - alien.size/2, alien.y - alien.size/2, alien.size, alien.size);
            });

            // Debug: draw a large test square to verify rendering
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(100, 100, 50, 50);

            // Draw bullets
            ctx.fillStyle = '#00ff00';
            demoBullets.forEach(bullet => {
                ctx.fillRect(bullet.x - 2, bullet.y - 2, 4, 4);
            });
        }

        // Main game loop
        let lastFrameTime = performance.now();
        let deltaTime = 1;

        function gameLoop() {
            requestAnimationFrame(gameLoop);

            if (gameState.gameOver) return;

            // Calculate delta time for frame-rate independence
            const currentTime = performance.now();
            const frameDelta = (currentTime - lastFrameTime) / (1000 / 60); // Normalize to 60 FPS
            lastFrameTime = currentTime;
            deltaTime = Math.min(frameDelta, 2); // Cap at 2x to prevent huge jumps

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawStars();

            if (!gameState.gameStarted) {
                // Show demo animation
                if (demoShips.length === 0) {
                    initDemoAnimation();
                }
                updateDemoAnimation();
                drawEarth();
                drawDemoAnimation();
            } else {
                // Normal game
                updatePlayer();
                updateBullets();
                updatePowerUps();
                updateAliens();
                updateExplosionParticles();
                updateMirrorShip();
                updateMedShip();
                updateMedPacks();
                // Superweapon updates
                updateActiveSuperweapon();
                updateSatellites();
                updateMissiles();
                checkShieldCollisions();
                checkSatelliteCollisions();
                checkMedShipCollisions();
                checkCollisions();
                updateStatusBars();

                drawEarth();
                // Draw superweapon effects
                drawShield();
                drawSatellites();
                drawQuadShips();
                drawPowerUps();
                drawPlayer();
                drawMirrorShip();
                drawExplosionParticles();
                drawBullets();
                drawMissiles();
                drawAliens();
                drawMedShip();
                drawMedPacks();
            }
        }

        // Start game function
        function startGame() {
            gameState.gameStarted = true;
            document.getElementById('startScreen').classList.add('hidden');
            startBackgroundMusic();
        }

        // Initialize game with loaded config
        function initGame() {
            // Assign data from config
            alienTypes = gameConfig.alienTypes;
            powerUpTypes = gameConfig.powerUpTypes;

            // Apply player starting stats from config
            gameState.lives = gameConfig.player.startingLives;
            gameState.earthHealth = gameConfig.player.startingEarthHealth;
            gameState.player.orbitRadius = gameConfig.player.orbitRadius;
            gameState.player.speed = gameConfig.player.startingRotationSpeed;
            gameState.player.baseSpeed = gameConfig.player.startingRotationSpeed;
            gameState.player.bulletSpeed = gameConfig.player.startingBulletSpeed;
            gameState.player.shootCooldownTime = gameConfig.player.startingFireRate;
            gameState.player.bulletMode = gameConfig.player.startingBulletMode;
            gameState.player.size = gameConfig.player.shipSize;

            // Set initial wave target from level 1 config
            const level1Config = gameConfig.levels.find(l => l.level === 1);
            if (level1Config) {
                gameState.waveTarget = level1Config.aliensToKill;
            }

            // Generate wave buttons for level chooser
            const waveGrid = document.getElementById('waveGrid');
            for (let i = 1; i <= 20; i++) {
                const btn = document.createElement('button');
                btn.className = 'wave-btn';
                btn.textContent = i;
                btn.onclick = () => jumpToWave(i);
                waveGrid.appendChild(btn);
            }

            updateUI();
            updateStatusBars();
            updateLeaderboard();
            gameLoop();
        }

        // Load config then initialize game
        loadGameConfig().then(success => {
            if (success) {
                initGame();
            }
        });
    </script>
</body>
</html>
